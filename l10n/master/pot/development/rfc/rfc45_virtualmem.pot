# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1998-2024
# This file is distributed under the same license as the GDAL package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: GDAL master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-04-22 19:28+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../source/development/rfc/rfc45_virtualmem.rst:5
msgid "RFC 45: GDAL datasets and raster bands as virtual memory mappings"
msgstr ""

#: ../../../source/development/rfc/rfc45_virtualmem.rst:7
msgid "Authors: Even Rouault"
msgstr ""

#: ../../../source/development/rfc/rfc45_virtualmem.rst:9
msgid "Contact: even dot rouault at spatialys.com"
msgstr ""

#: ../../../source/development/rfc/rfc45_virtualmem.rst:11
msgid "Status: Adopted, implemented"
msgstr ""

#: ../../../source/development/rfc/rfc45_virtualmem.rst:14
msgid "Summary"
msgstr ""

#: ../../../source/development/rfc/rfc45_virtualmem.rst:16
msgid ""
"This document proposes additions to GDAL so that image data of GDAL datasets "
"and raster bands can be seen as virtual memory mappings, for hopefully "
"simpler usage."
msgstr ""

#: ../../../source/development/rfc/rfc45_virtualmem.rst:21
msgid "Rationale"
msgstr ""

#: ../../../source/development/rfc/rfc45_virtualmem.rst:23
msgid ""
"When one wants to read or write image data from/into a GDAL dataset or "
"raster band, one must use the RasterIO() interface for the regions of "
"interest that are read or written. For small images, the most convenient "
"solution is usually to read/write the whole image in a single request where "
"the region of interest is the full raster extent. For larger images, "
"particularly when they do not fit entirely in RAM, this is not possible, and "
"if one wants to operate on the whole image, one must use a windowing "
"strategy to avoid memory issues : typically by proceeding scanline (or group "
"of scanlines) by scanline, or by blocks for tiled images. This can make the "
"writing of algorithms more complicated when they need to access a "
"neighbourhood of pixels around each pixel of interest, since the size of "
"this extra window must be taken into account, leading to overlapping regions "
"of interests. Nothing that cannot be solved, but that requires some "
"additional thinking that distracts from the followed main purpose."
msgstr ""

#: ../../../source/development/rfc/rfc45_virtualmem.rst:39
msgid ""
"The proposed addition of this RFC is to make the image data appear as a "
"single array accessed with a pointer, without being limited by the size of "
"RAM with respect to the size of the dataset (excepted limitations imposed by "
"the CPU architecture and the operating system)"
msgstr ""

#: ../../../source/development/rfc/rfc45_virtualmem.rst:45
msgid "Technical solution"
msgstr ""

#: ../../../source/development/rfc/rfc45_virtualmem.rst:48
msgid "Low-level machinery : cpl_virtualmem.h"
msgstr ""

#: ../../../source/development/rfc/rfc45_virtualmem.rst:50
msgid ""
"The low-level machinery to support this new capability is a CPLVirtualMem "
"object that represents an area of virtual memory ( on Linux, an area of "
"virtual memory allocated by the mmap() function ). This virtual memory area "
"is initially just reserved in terms of virtual memory space, but has no "
"actual allocation in physical memory. This reserved virtual memory space is "
"protected with an access permission that cause any attempt to access it to "
"result in an exception - a page fault, that on POSIX systems triggers a "
"SIGSEGV signal (segmentation fault). Fortunately, segmentation faults can be "
"caught by the software with a signal handler. When such a segmentation fault "
"occurs, our specialized signal handler will check if it occurs in a virtual "
"memory region under its responsibility and, if so, it will proceed to fill "
"the part (a \"page\") of the virtual memory area that has been accessed with "
"sensible values (thanks to a user provided callback). It will then set "
"appropriate permissions to the page (read-only or read-write), before "
"attempting again the instruction that triggered the segmentation fault. From "
"the point of view of the user code that accesses the memory mapping, this is "
"completely transparent, and this is equivalent as if the whole virtual "
"memory area had been filled from the start."
msgstr ""

#: ../../../source/development/rfc/rfc45_virtualmem.rst:70
msgid ""
"For very large mappings that are larger than RAM, this would still cause "
"disk swapping to occur at a certain point. To avoid that, the segmentation "
"fault handler will evict the least recently used pages, once a threshold "
"defined at the creation of the CPLVirtualMem object has been reached."
msgstr ""

#: ../../../source/development/rfc/rfc45_virtualmem.rst:76
msgid ""
"For write support, another callback can be passed. It will be called before "
"a page is evicted so that user code has a chance to flush its content to a "
"more persistent storage."
msgstr ""

#: ../../../source/development/rfc/rfc45_virtualmem.rst:80
msgid ""
"We also offer an alternative way of creating a CPLVirtualMem object, by "
"using memory file mapping mechanisms. This may be used by \"raw\" datasets "
"(EHdr driver for example) where the organization of data on disk directly "
"matches the organization of a in-memory array."
msgstr ""

#: ../../../source/development/rfc/rfc45_virtualmem.rst:86
msgid "High-level usage"
msgstr ""

#: ../../../source/development/rfc/rfc45_virtualmem.rst:88
msgid "Four new API are introduced (detailed in further section):"
msgstr ""

#: ../../../source/development/rfc/rfc45_virtualmem.rst:90
msgid ""
"GDALDatasetGetVirtualMem() : takes almost the same arguments as "
"GDALDatasetRasterIO(), with the notable exception of a pData buffer. It "
"returns a CPLVirtualMem\\* object, from which the base address of the "
"virtual memory mapping can be obtained with CPLVirtualMemGetAddr()."
msgstr ""

#: ../../../source/development/rfc/rfc45_virtualmem.rst:98
msgid ""
"GDALRasterBandGetVirtualMem(): equivalent of GDALDatasetGetVirtualMem() that "
"operates on a raster band object rather than a dataset object."
msgstr ""

#: ../../../source/development/rfc/rfc45_virtualmem.rst:102
msgid ""
"GDALDatasetGetTiledVirtualMem(): this is a rather original API. Instead of "
"presenting a 2D view of the image data (i.e. organized rows by rows), the "
"mapping exposes it as an array of tiles, which is more suitable, performance "
"wise, when the dataset is itself tiled."
msgstr ""

#: ../../../source/development/rfc/rfc45_virtualmem.rst:109
msgid ""
"When they are several bands, 3 different organizations of band components "
"are possible. To the best of our knowledge, there is no standard way of "
"calling those organizations, which consequently will be best illustrated by "
"the following schemas :"
msgstr ""

#: ../../../source/development/rfc/rfc45_virtualmem.rst:-1
#: ../../../source/development/rfc/rfc45_virtualmem.rst:114
msgid "TIP / Tile Interleaved by Pixel"
msgstr ""

#: ../../../source/development/rfc/rfc45_virtualmem.rst:-1
#: ../../../source/development/rfc/rfc45_virtualmem.rst:119
msgid "BIT / Band Interleaved by Tile"
msgstr ""

#: ../../../source/development/rfc/rfc45_virtualmem.rst:-1
#: ../../../source/development/rfc/rfc45_virtualmem.rst:124
msgid "BSQ / Band SeQuential organization"
msgstr ""

#: ../../../source/development/rfc/rfc45_virtualmem.rst:129
msgid ""
"GDALRasterBandGetTiledVirtualMem(): equivalent of "
"GDALDatasetGetTiledVirtualMem() that operates on a raster band object rather "
"than a dataset object."
msgstr ""

#: ../../../source/development/rfc/rfc45_virtualmem.rst:133
msgid ""
"GDALGetVirtualMemAuto(): simplified version of GDALRasterBandGetVirtualMem() "
"where the user only specifies the access mode. The pixel spacing and line "
"spacing are returned by the function. This is implemented as a virtual "
"method at the GDALRasterBand level, so that drivers have a chance of "
"overriding the base implementation. The base implementation just uses "
"GDALRasterBandGetVirtualMem(). Overridden implementation may use the memory "
"file mapping mechanism instead. Such implementations will be done in the "
"RawRasterBand object and in the GeoTIFF driver."
msgstr ""

#: ../../../source/development/rfc/rfc45_virtualmem.rst:144
msgid "Details of new API"
msgstr ""

#: ../../../source/development/rfc/rfc45_virtualmem.rst:149
msgid "Implemented by cpl_virtualmem.cpp"
msgstr ""

#: ../../../source/development/rfc/rfc45_virtualmem.rst:153
msgid ""
"/**\n"
" * \\file cpl_virtualmem.h\n"
" *\n"
" * Virtual memory management.\n"
" *\n"
" * This file provides mechanism to define virtual memory mappings, whose "
"content\n"
" * is allocated transparently and filled on-the-fly. Those virtual memory "
"mappings\n"
" * can be much larger than the available RAM, but only parts of the virtual\n"
" * memory mapping, in the limit of the allowed the cache size, will actually "
"be\n"
" * physically allocated.\n"
" *\n"
" * This exploits low-level mechanisms of the operating system (virtual "
"memory\n"
" * allocation, page protection and handler of virtual memory exceptions).\n"
" *\n"
" * It is also possible to create a virtual memory mapping from a file or "
"part\n"
" * of a file.\n"
" *\n"
" * The current implementation is Linux only.\n"
" */\n"
"\n"
"/** Opaque type that represents a virtual memory mapping. */\n"
"typedef struct CPLVirtualMem CPLVirtualMem;\n"
"\n"
"/** Callback triggered when a still unmapped page of virtual memory is "
"accessed.\n"
"  * The callback has the responsibility of filling the page with relevant "
"values\n"
"  *\n"
"  * @param ctxt virtual memory handle.\n"
"  * @param nOffset offset of the page in the memory mapping.\n"
"  * @param pPageToFill address of the page to fill. Note that the address "
"might\n"
"  *                    be a temporary location, and not at "
"CPLVirtualMemGetAddr() + nOffset.\n"
"  * @param nToFill number of bytes of the page.\n"
"  * @param pUserData user data that was passed to CPLVirtualMemNew().\n"
"  */\n"
"typedef void (*CPLVirtualMemCachePageCbk)(CPLVirtualMem* ctxt,\n"
"                                    size_t nOffset,\n"
"                                    void* pPageToFill,\n"
"                                    size_t nToFill,\n"
"                                    void* pUserData);\n"
"\n"
"/** Callback triggered when a dirty mapped page is going to be freed.\n"
"  * (saturation of cache, or termination of the virtual memory mapping).\n"
"  *\n"
"  * @param ctxt virtual memory handle.\n"
"  * @param nOffset offset of the page in the memory mapping.\n"
"  * @param pPageToBeEvicted address of the page that will be flushed. Note "
"that the address might\n"
"  *                    be a temporary location, and not at "
"CPLVirtualMemGetAddr() + nOffset.\n"
"  * @param nToBeEvicted number of bytes of the page.\n"
"  * @param pUserData user data that was passed to CPLVirtualMemNew().\n"
"  */\n"
"typedef void (*CPLVirtualMemUnCachePageCbk)(CPLVirtualMem* ctxt,\n"
"                                      size_t nOffset,\n"
"                                      const void* pPageToBeEvicted,\n"
"                                      size_t nToBeEvicted,\n"
"                                      void* pUserData);\n"
"\n"
"/** Callback triggered when a virtual memory mapping is destroyed.\n"
"  * @param pUserData user data that was passed to CPLVirtualMemNew().\n"
" */\n"
"typedef void (*CPLVirtualMemFreeUserData)(void* pUserData);\n"
"\n"
"/** Access mode of a virtual memory mapping. */\n"
"typedef enum\n"
"{\n"
"    /*! The mapping is meant at being read-only, but writes will not be "
"prevented.\n"
"        Note that any content written will be lost. */\n"
"    VIRTUALMEM_READONLY,\n"
"    /*! The mapping is meant at being read-only, and this will be enforced\n"
"        through the operating system page protection mechanism. */\n"
"    VIRTUALMEM_READONLY_ENFORCED,\n"
"    /*! The mapping is meant at being read-write, and modified pages can be "
"saved\n"
"        thanks to the pfnUnCachePage callback */\n"
"    VIRTUALMEM_READWRITE\n"
"} CPLVirtualMemAccessMode;\n"
"\n"
"\n"
"/** Return the size of a page of virtual memory.\n"
" *\n"
" * @return the page size.\n"
" *\n"
" * @since GDAL 1.11\n"
" */\n"
"size_t CPL_DLL CPLGetPageSize(void);\n"
"\n"
"/** Create a new virtual memory mapping.\n"
" *\n"
" * This will reserve an area of virtual memory of size nSize, whose size\n"
" * might be potentially much larger than the physical memory available. "
"Initially,\n"
" * no physical memory will be allocated. As soon as memory pages will be "
"accessed,\n"
" * they will be allocated transparently and filled with the pfnCachePage "
"callback.\n"
" * When the allowed cache size is reached, the least recently used pages "
"will\n"
" * be unallocated.\n"
" *\n"
" * On Linux AMD64 platforms, the maximum value for nSize is 128 TB.\n"
" * On Linux x86 platforms, the maximum value for nSize is 2 GB.\n"
" *\n"
" * Only supported on Linux for now.\n"
" *\n"
" * Note that on Linux, this function will install a SIGSEGV handler. The\n"
" * original handler will be restored by CPLVirtualMemManagerTerminate().\n"
" *\n"
" * @param nSize size in bytes of the virtual memory mapping.\n"
" * @param nCacheSize   size in bytes of the maximum memory that will be "
"really\n"
" *                     allocated (must ideally fit into RAM).\n"
" * @param nPageSizeHint hint for the page size. Must be a multiple of the\n"
" *                      system page size, returned by CPLGetPageSize().\n"
" *                      Minimum value is generally 4096. Might be set to 0 "
"to\n"
" *                      let the function determine a default page size.\n"
" * @param bSingleThreadUsage set to TRUE if there will be no concurrent "
"threads\n"
" *                           that will access the virtual memory mapping. "
"This can\n"
" *                           optimize performance a bit.\n"
" * @param eAccessMode permission to use for the virtual memory mapping.\n"
" * @param pfnCachePage callback triggered when a still unmapped page of "
"virtual\n"
" *                     memory is accessed. The callback has the "
"responsibility\n"
" *                     of filling the page with relevant values.\n"
" * @param pfnUnCachePage callback triggered when a dirty mapped page is "
"going to\n"
" *                       be freed (saturation of cache, or termination of "
"the\n"
" *                       virtual memory mapping). Might be NULL.\n"
" * @param pfnFreeUserData callback that can be used to free pCbkUserData. "
"Might be\n"
" *                        NULL\n"
" * @param pCbkUserData user data passed to pfnCachePage and pfnUnCachePage.\n"
" *\n"
" * @return a virtual memory object that must be freed by "
"CPLVirtualMemFree(),\n"
" *         or NULL in case of failure.\n"
" *\n"
" * @since GDAL 1.11\n"
" */\n"
"\n"
"CPLVirtualMem CPL_DLL *CPLVirtualMemNew(size_t nSize,\n"
"                                        size_t nCacheSize,\n"
"                                        size_t nPageSizeHint,\n"
"                                        int bSingleThreadUsage,\n"
"                                        CPLVirtualMemAccessMode "
"eAccessMode,\n"
"                                        CPLVirtualMemCachePageCbk "
"pfnCachePage,\n"
"                                        CPLVirtualMemUnCachePageCbk "
"pfnUnCachePage,\n"
"                                        CPLVirtualMemFreeUserData "
"pfnFreeUserData,\n"
"                                        void *pCbkUserData);\n"
"\n"
"\n"
"/** Return if virtual memory mapping of a file is available.\n"
" *\n"
" * @return TRUE if virtual memory mapping of a file is available.\n"
" * @since GDAL 1.11\n"
" */\n"
"int CPL_DLL CPLIsVirtualMemFileMapAvailable(void);\n"
"\n"
"/** Create a new virtual memory mapping from a file.\n"
" *\n"
" * The file must be a \"real\" file recognized by the operating system, and "
"not\n"
" * a VSI extended virtual file.\n"
" *\n"
" * In VIRTUALMEM_READWRITE mode, updates to the memory mapping will be "
"written\n"
" * in the file.\n"
" *\n"
" * On Linux AMD64 platforms, the maximum value for nLength is 128 TB.\n"
" * On Linux x86 platforms, the maximum value for nLength is 2 GB.\n"
" *\n"
" * Only supported on Linux for now.\n"
" *\n"
" * @param  fp       Virtual file handle.\n"
" * @param  nOffset  Offset in the file to start the mapping from.\n"
" * @param  nLength  Length of the portion of the file to map into memory.\n"
" * @param eAccessMode Permission to use for the virtual memory mapping. This "
"must\n"
" *                    be consistent with how the file has been opened.\n"
" * @param pfnFreeUserData callback that is called when the object is "
"destroyed.\n"
" * @param pCbkUserData user data passed to pfnFreeUserData.\n"
" * @return a virtual memory object that must be freed by "
"CPLVirtualMemFree(),\n"
" *         or NULL in case of failure.\n"
" *\n"
" * @since GDAL 1.11\n"
" */\n"
"CPLVirtualMem CPL_DLL *CPLVirtualMemFileMapNew( VSILFILE* fp,\n"
"                                                vsi_l_offset nOffset,\n"
"                                                vsi_l_offset nLength,\n"
"                                                CPLVirtualMemAccessMode "
"eAccessMode,\n"
"                                                CPLVirtualMemFreeUserData "
"pfnFreeUserData,\n"
"                                                void *pCbkUserData );\n"
"\n"
"/** Create a new virtual memory mapping derived from an other virtual "
"memory\n"
" *  mapping.\n"
" *\n"
" * This may be useful in case of creating mapping for pixel interleaved "
"data.\n"
" *\n"
" * The new mapping takes a reference on the base mapping.\n"
" *\n"
" * @param pVMemBase Base virtual memory mapping\n"
" * @param nOffset   Offset in the base virtual memory mapping from which to "
"start\n"
" *                  the new mapping.\n"
" * @param nSize     Size of the base virtual memory mapping to expose in "
"the\n"
" *                  the new mapping.\n"
" * @param pfnFreeUserData callback that is called when the object is "
"destroyed.\n"
" * @param pCbkUserData user data passed to pfnFreeUserData.\n"
" * @return a virtual memory object that must be freed by "
"CPLVirtualMemFree(),\n"
" *         or NULL in case of failure.\n"
" *\n"
" * @since GDAL 1.11\n"
" */\n"
"CPLVirtualMem CPL_DLL *CPLVirtualMemDerivedNew(CPLVirtualMem* pVMemBase,\n"
"                                               vsi_l_offset nOffset,\n"
"                                               vsi_l_offset nSize,\n"
"                                               CPLVirtualMemFreeUserData "
"pfnFreeUserData,\n"
"                                               void *pCbkUserData);\n"
"\n"
"/** Free a virtual memory mapping.\n"
" *\n"
" * The pointer returned by CPLVirtualMemGetAddr() will no longer be valid.\n"
" * If the virtual memory mapping was created with read/write permissions and "
"that\n"
" * they are dirty (i.e. modified) pages, they will be flushed through the\n"
" * pfnUnCachePage callback before being freed.\n"
" *\n"
" * @param ctxt context returned by CPLVirtualMemNew().\n"
" *\n"
" * @since GDAL 1.11\n"
" */\n"
"void CPL_DLL CPLVirtualMemFree(CPLVirtualMem* ctxt);\n"
"\n"
"/** Return the pointer to the start of a virtual memory mapping.\n"
" *\n"
" * The bytes in the range [p:p+CPLVirtualMemGetSize()-1] where p is the "
"pointer\n"
" * returned by this function will be valid, until CPLVirtualMemFree() is "
"called.\n"
" *\n"
" * Note that if a range of bytes used as an argument of a system call\n"
" * (such as read() or write()) contains pages that have not been "
"\"realized\", the\n"
" * system call will fail with EFAULT. CPLVirtualMemPin() can be used to "
"work\n"
" * around this issue.\n"
" *\n"
" * @param ctxt context returned by CPLVirtualMemNew().\n"
" * @return the pointer to the start of a virtual memory mapping.\n"
" *\n"
" * @since GDAL 1.11\n"
" */\n"
"void CPL_DLL *CPLVirtualMemGetAddr(CPLVirtualMem* ctxt);\n"
"\n"
"/** Return the size of the virtual memory mapping.\n"
" *\n"
" * @param ctxt context returned by CPLVirtualMemNew().\n"
" * @return the size of the virtual memory mapping.\n"
" *\n"
" * @since GDAL 1.11\n"
" */\n"
"size_t CPL_DLL CPLVirtualMemGetSize(CPLVirtualMem* ctxt);\n"
"\n"
"/** Return if the virtual memory mapping is a direct file mapping.\n"
" *\n"
" * @param ctxt context returned by CPLVirtualMemNew().\n"
" * @return TRUE if the virtual memory mapping is a direct file mapping.\n"
" *\n"
" * @since GDAL 1.11\n"
" */\n"
"int CPL_DLL CPLVirtualMemIsFileMapping(CPLVirtualMem* ctxt);\n"
"\n"
"/** Return the access mode of the virtual memory mapping.\n"
" *\n"
" * @param ctxt context returned by CPLVirtualMemNew().\n"
" * @return the access mode of the virtual memory mapping.\n"
" *\n"
" * @since GDAL 1.11\n"
" */\n"
"CPLVirtualMemAccessMode CPL_DLL CPLVirtualMemGetAccessMode(CPLVirtualMem* "
"ctxt);\n"
"\n"
"/** Return the page size associated to a virtual memory mapping.\n"
" *\n"
" * The value returned will be at least CPLGetPageSize(), but potentially\n"
" * larger.\n"
" *\n"
" * @param ctxt context returned by CPLVirtualMemNew().\n"
" * @return the page size\n"
" *\n"
" * @since GDAL 1.11\n"
" */\n"
"size_t CPL_DLL CPLVirtualMemGetPageSize(CPLVirtualMem* ctxt);\n"
"\n"
"/** Return TRUE if this memory mapping can be accessed safely from "
"concurrent\n"
" *  threads.\n"
" *\n"
" * The situation that can cause problems is when several threads try to "
"access\n"
" * a page of the mapping that is not yet mapped.\n"
" *\n"
" * The return value of this function depends on whether bSingleThreadUsage "
"has\n"
" * been set of not in CPLVirtualMemNew() and/or the implementation.\n"
" *\n"
" * On Linux, this will always return TRUE if bSingleThreadUsage = FALSE.\n"
" *\n"
" * @param ctxt context returned by CPLVirtualMemNew().\n"
" * @return TRUE if this memory mapping can be accessed safely from "
"concurrent\n"
" *         threads.\n"
" *\n"
" * @since GDAL 1.11\n"
" */\n"
"int CPL_DLL CPLVirtualMemIsAccessThreadSafe(CPLVirtualMem* ctxt);\n"
"\n"
"/** Declare that a thread will access a virtual memory mapping.\n"
" *\n"
" * This function must be called by a thread that wants to access the\n"
" * content of a virtual memory mapping, except if the virtual memory mapping "
"has\n"
" * been created with bSingleThreadUsage = TRUE.\n"
" *\n"
" * This function must be paired with CPLVirtualMemUnDeclareThread().\n"
" *\n"
" * @param ctxt context returned by CPLVirtualMemNew().\n"
" *\n"
" * @since GDAL 1.11\n"
" */\n"
"void CPL_DLL CPLVirtualMemDeclareThread(CPLVirtualMem* ctxt);\n"
"\n"
"/** Declare that a thread will stop accessing a virtual memory mapping.\n"
" *\n"
" * This function must be called by a thread that will no longer access the\n"
" * content of a virtual memory mapping, except if the virtual memory mapping "
"has\n"
" * been created with bSingleThreadUsage = TRUE.\n"
" *\n"
" * This function must be paired with CPLVirtualMemDeclareThread().\n"
" *\n"
" * @param ctxt context returned by CPLVirtualMemNew().\n"
" *\n"
" * @since GDAL 1.11\n"
" */\n"
"void CPL_DLL CPLVirtualMemUnDeclareThread(CPLVirtualMem* ctxt);\n"
"\n"
"/** Make sure that a region of virtual memory will be realized.\n"
" *\n"
" * Calling this function is not required, but might be useful when "
"debugging\n"
" * a process with tools like gdb or valgrind that do not naturally like\n"
" * segmentation fault signals.\n"
" *\n"
" * It is also needed when wanting to provide part of virtual memory mapping\n"
" * to a system call such as read() or write(). If read() or write() is "
"called\n"
" * on a memory region not yet realized, the call will fail with EFAULT.\n"
" *\n"
" * @param ctxt context returned by CPLVirtualMemNew().\n"
" * @param pAddr the memory region to pin.\n"
" * @param nSize the size of the memory region.\n"
" * @param bWriteOp set to TRUE if the memory are will be accessed in write "
"mode.\n"
" *\n"
" * @since GDAL 1.11\n"
" */\n"
"void CPL_DLL CPLVirtualMemPin(CPLVirtualMem* ctxt,\n"
"                              void* pAddr, size_t nSize, int bWriteOp);\n"
"\n"
"/** Cleanup any resource and handlers related to virtual memory.\n"
" *\n"
" * This function must be called after the last CPLVirtualMem object has\n"
" * been freed.\n"
" *\n"
" * @since GDAL 1.11\n"
" */\n"
"void CPL_DLL CPLVirtualMemManagerTerminate(void);"
msgstr ""

#: ../../../source/development/rfc/rfc45_virtualmem.rst:503
msgid "Implemented by gdalvirtualmem.cpp"
msgstr ""

#: ../../../source/development/rfc/rfc45_virtualmem.rst:508
msgid ""
"/** Create a CPLVirtualMem object from a GDAL dataset object.\n"
" *\n"
" * Only supported on Linux for now.\n"
" *\n"
" * This method allows creating a virtual memory object for a region of one\n"
" * or more GDALRasterBands from  this dataset. The content of the virtual\n"
" * memory object is automatically filled from dataset content when a "
"virtual\n"
" * memory page is first accessed, and it is released (or flushed in case of "
"a\n"
" * \"dirty\" page) when the cache size limit has been reached.\n"
" *\n"
" * The pointer to access the virtual memory object is obtained with\n"
" * CPLVirtualMemGetAddr(). It remains valid until CPLVirtualMemFree() is "
"called.\n"
" * CPLVirtualMemFree() must be called before the dataset object is "
"destroyed.\n"
" *\n"
" * If p is such a pointer and base_type the C type matching eBufType, for "
"default\n"
" * values of spacing parameters, the element of image coordinates (x, y)\n"
" * (relative to xOff, yOff) for band b can be accessed with\n"
" * ((base_type*)p)[x + y * nBufXSize + (b-1)*nBufXSize*nBufYSize].\n"
" *\n"
" * Note that the mechanism used to transparently fill memory pages when they "
"are\n"
" * accessed is the same (but in a controlled way) than what occurs when a "
"memory\n"
" * error occurs in a program. Debugging software will generally interrupt "
"program\n"
" * execution when that happens. If needed, CPLVirtualMemPin() can be used to "
"avoid\n"
" * that by ensuring memory pages are allocated before being accessed.\n"
" *\n"
" * The size of the region that can be mapped as a virtual memory object "
"depends\n"
" * on hardware and operating system limitations.\n"
" * On Linux AMD64 platforms, the maximum value is 128 TB.\n"
" * On Linux x86 platforms, the maximum value is 2 GB.\n"
" *\n"
" * Data type translation is automatically done if the data type\n"
" * (eBufType) of the buffer is different than\n"
" * that of the GDALRasterBand.\n"
" *\n"
" * Image decimation / replication is currently not supported, i.e. if the\n"
" * size of the region being accessed (nXSize x nYSize) is different from "
"the\n"
" * buffer size (nBufXSize x nBufYSize).\n"
" *\n"
" * The nPixelSpace, nLineSpace and nBandSpace parameters allow reading into "
"or\n"
" * writing from various organization of buffers. Arbitrary values for the "
"spacing\n"
" * parameters are not supported. Those values must be multiple of the size "
"of the\n"
" * buffer data type, and must be either band sequential organization "
"(typically\n"
" * nPixelSpace = GDALGetDataTypeSize(eBufType) / 8, nLineSpace = nPixelSpace "
"* nBufXSize,\n"
" * nBandSpace = nLineSpace * nBufYSize), or pixel-interleaved organization\n"
" * (typically nPixelSpace = nBandSpace * nBandCount, nLineSpace = "
"nPixelSpace * nBufXSize,\n"
" * nBandSpace = GDALGetDataTypeSize(eBufType) / 8)\n"
" *\n"
" * @param hDS Dataset object\n"
" *\n"
" * @param eRWFlag Either GF_Read to read a region of data, or GF_Write to\n"
" * write a region of data.\n"
" *\n"
" * @param nXOff The pixel offset to the top left corner of the region\n"
" * of the band to be accessed.  This would be zero to start from the left "
"side.\n"
" *\n"
" * @param nYOff The line offset to the top left corner of the region\n"
" * of the band to be accessed.  This would be zero to start from the top.\n"
" *\n"
" * @param nXSize The width of the region of the band to be accessed in "
"pixels.\n"
" *\n"
" * @param nYSize The height of the region of the band to be accessed in "
"lines.\n"
" *\n"
" * @param nBufXSize the width of the buffer image into which the desired "
"region\n"
" * is to be read, or from which it is to be written.\n"
" *\n"
" * @param nBufYSize the height of the buffer image into which the desired\n"
" * region is to be read, or from which it is to be written.\n"
" *\n"
" * @param eBufType the type of the pixel values in the data buffer. The\n"
" * pixel values will automatically be translated to/from the GDALRasterBand\n"
" * data type as needed.\n"
" *\n"
" * @param nBandCount the number of bands being read or written.\n"
" *\n"
" * @param panBandMap the list of nBandCount band numbers being read/"
"written.\n"
" * Note band numbers are 1 based. This may be NULL to select the first\n"
" * nBandCount bands.\n"
" *\n"
" * @param nPixelSpace The byte offset from the start of one pixel value in\n"
" * the buffer to the start of the next pixel value within a scanline. If "
"defaulted\n"
" * (0) the size of the datatype eBufType is used.\n"
" *\n"
" * @param nLineSpace The byte offset from the start of one scanline in\n"
" * the buffer to the start of the next. If defaulted (0) the size of the "
"datatype\n"
" * eBufType * nBufXSize is used.\n"
" *\n"
" * @param nBandSpace the byte offset from the start of one bands data to "
"the\n"
" * start of the next. If defaulted (0) the value will be\n"
" * nLineSpace * nBufYSize implying band sequential organization\n"
" * of the data buffer.\n"
" *\n"
" * @param nCacheSize   size in bytes of the maximum memory that will be "
"really\n"
" *                     allocated (must ideally fit into RAM)\n"
" *\n"
" * @param nPageSizeHint hint for the page size. Must be a multiple of the\n"
" *                      system page size, returned by CPLGetPageSize().\n"
" *                      Minimum value is generally 4096. Might be set to 0 "
"to\n"
" *                      let the function determine a default page size.\n"
" *\n"
" * @param bSingleThreadUsage set to TRUE if there will be no concurrent "
"threads\n"
" *                           that will access the virtual memory mapping. "
"This can\n"
" *                           optimize performance a bit. If set to FALSE,\n"
" *                           CPLVirtualMemDeclareThread() must be called.\n"
" *\n"
" * @param papszOptions NULL terminated list of options. Unused for now.\n"
" *\n"
" * @return a virtual memory object that must be freed by "
"CPLVirtualMemFree(),\n"
" *         or NULL in case of failure.\n"
" *\n"
" * @since GDAL 1.11\n"
" */\n"
"\n"
"CPLVirtualMem CPL_DLL* GDALDatasetGetVirtualMem( GDALDatasetH hDS,\n"
"                                         GDALRWFlag eRWFlag,\n"
"                                         int nXOff, int nYOff,\n"
"                                         int nXSize, int nYSize,\n"
"                                         int nBufXSize, int nBufYSize,\n"
"                                         GDALDataType eBufType,\n"
"                                         int nBandCount, int* panBandMap,\n"
"                                         int nPixelSpace,\n"
"                                         GIntBig nLineSpace,\n"
"                                         GIntBig nBandSpace,\n"
"                                         size_t nCacheSize,\n"
"                                         size_t nPageSizeHint,\n"
"                                         int bSingleThreadUsage,\n"
"                                         char **papszOptions );\n"
"\n"
"** Create a CPLVirtualMem object from a GDAL raster band object.\n"
" *\n"
" * Only supported on Linux for now.\n"
" *\n"
" * This method allows creating a virtual memory object for a region of a\n"
" * GDALRasterBand. The content of the virtual\n"
" * memory object is automatically filled from dataset content when a "
"virtual\n"
" * memory page is first accessed, and it is released (or flushed in case of "
"a\n"
" * \"dirty\" page) when the cache size limit has been reached.\n"
" *\n"
" * The pointer to access the virtual memory object is obtained with\n"
" * CPLVirtualMemGetAddr(). It remains valid until CPLVirtualMemFree() is "
"called.\n"
" * CPLVirtualMemFree() must be called before the raster band object is "
"destroyed.\n"
" *\n"
" * If p is such a pointer and base_type the C type matching eBufType, for "
"default\n"
" * values of spacing parameters, the element of image coordinates (x, y)\n"
" * (relative to xOff, yOff) can be accessed with\n"
" * ((base_type*)p)[x + y * nBufXSize].\n"
" *\n"
" * Note that the mechanism used to transparently fill memory pages when they "
"are\n"
" * accessed is the same (but in a controlled way) than what occurs when a "
"memory\n"
" * error occurs in a program. Debugging software will generally interrupt "
"program\n"
" * execution when that happens. If needed, CPLVirtualMemPin() can be used to "
"avoid\n"
" * that by ensuring memory pages are allocated before being accessed.\n"
" *\n"
" * The size of the region that can be mapped as a virtual memory object "
"depends\n"
" * on hardware and operating system limitations.\n"
" * On Linux AMD64 platforms, the maximum value is 128 TB.\n"
" * On Linux x86 platforms, the maximum value is 2 GB.\n"
" *\n"
" * Data type translation is automatically done if the data type\n"
" * (eBufType) of the buffer is different than\n"
" * that of the GDALRasterBand.\n"
" *\n"
" * Image decimation / replication is currently not supported, i.e. if the\n"
" * size of the region being accessed (nXSize x nYSize) is different from "
"the\n"
" * buffer size (nBufXSize x nBufYSize).\n"
" *\n"
" * The nPixelSpace and nLineSpace parameters allow reading into or\n"
" * writing from various organization of buffers. Arbitrary values for the "
"spacing\n"
" * parameters are not supported. Those values must be multiple of the size "
"of the\n"
" * buffer data type and must be such that nLineSpace >= nPixelSpace * "
"nBufXSize.\n"
" *\n"
" * @param hBand Rasterband object\n"
" *\n"
" * @param eRWFlag Either GF_Read to read a region of data, or GF_Write to\n"
" * write a region of data.\n"
" *\n"
" * @param nXOff The pixel offset to the top left corner of the region\n"
" * of the band to be accessed.  This would be zero to start from the left "
"side.\n"
" *\n"
" * @param nYOff The line offset to the top left corner of the region\n"
" * of the band to be accessed.  This would be zero to start from the top.\n"
" *\n"
" * @param nXSize The width of the region of the band to be accessed in "
"pixels.\n"
" *\n"
" * @param nYSize The height of the region of the band to be accessed in "
"lines.\n"
" *\n"
" * @param nBufXSize the width of the buffer image into which the desired "
"region\n"
" * is to be read, or from which it is to be written.\n"
" *\n"
" * @param nBufYSize the height of the buffer image into which the desired\n"
" * region is to be read, or from which it is to be written.\n"
" *\n"
" * @param eBufType the type of the pixel values in the data buffer. The\n"
" * pixel values will automatically be translated to/from the GDALRasterBand\n"
" * data type as needed.\n"
" *\n"
" * @param nPixelSpace The byte offset from the start of one pixel value in\n"
" * the buffer to the start of the next pixel value within a scanline. If "
"defaulted\n"
" * (0) the size of the datatype eBufType is used.\n"
" *\n"
" * @param nLineSpace The byte offset from the start of one scanline in\n"
" * the buffer to the start of the next. If defaulted (0) the size of the "
"datatype\n"
" * eBufType * nBufXSize is used.\n"
" *\n"
" * @param nCacheSize   size in bytes of the maximum memory that will be "
"really\n"
" *                     allocated (must ideally fit into RAM)\n"
" *\n"
" * @param nPageSizeHint hint for the page size. Must be a multiple of the\n"
" *                      system page size, returned by CPLGetPageSize().\n"
" *                      Minimum value is generally 4096. Might be set to 0 "
"to\n"
" *                      let the function determine a default page size.\n"
" *\n"
" * @param bSingleThreadUsage set to TRUE if there will be no concurrent "
"threads\n"
" *                           that will access the virtual memory mapping. "
"This can\n"
" *                           optimize performance a bit. If set to FALSE,\n"
" *                           CPLVirtualMemDeclareThread() must be called.\n"
" *\n"
" * @param papszOptions NULL terminated list of options. Unused for now.\n"
" *\n"
" * @return a virtual memory object that must be freed by "
"CPLVirtualMemFree(),\n"
" *         or NULL in case of failure.\n"
" *\n"
" * @since GDAL 1.11\n"
" */\n"
"\n"
"CPLVirtualMem CPL_DLL* GDALRasterBandGetVirtualMem( GDALRasterBandH hBand,\n"
"                                         GDALRWFlag eRWFlag,\n"
"                                         int nXOff, int nYOff,\n"
"                                         int nXSize, int nYSize,\n"
"                                         int nBufXSize, int nBufYSize,\n"
"                                         GDALDataType eBufType,\n"
"                                         int nPixelSpace,\n"
"                                         GIntBig nLineSpace,\n"
"                                         size_t nCacheSize,\n"
"                                         size_t nPageSizeHint,\n"
"                                         int bSingleThreadUsage,\n"
"                                         char **papszOptions );\n"
"\n"
"typedef enum\n"
"{\n"
"    /*! Tile Interleaved by Pixel: tile (0,0) with internal band "
"interleaved\n"
"        by pixel organization, tile (1, 0), ...  */\n"
"    GTO_TIP,\n"
"    /*! Band Interleaved by Tile : tile (0,0) of first band, tile (0,0) of "
"second\n"
"        band, ... tile (1,0) of first band, tile (1,0) of second band, ... "
"*/\n"
"    GTO_BIT,\n"
"    /*! Band SeQuential : all the tiles of first band, all the tiles of "
"following band... */\n"
"    GTO_BSQ\n"
"} GDALTileOrganization;\n"
"\n"
"/** Create a CPLVirtualMem object from a GDAL dataset object, with tiling\n"
" * organization\n"
" *\n"
" * Only supported on Linux for now.\n"
" *\n"
" * This method allows creating a virtual memory object for a region of one\n"
" * or more GDALRasterBands from  this dataset. The content of the virtual\n"
" * memory object is automatically filled from dataset content when a "
"virtual\n"
" * memory page is first accessed, and it is released (or flushed in case of "
"a\n"
" * \"dirty\" page) when the cache size limit has been reached.\n"
" *\n"
" * Contrary to GDALDatasetGetVirtualMem(), pixels will be organized by "
"tiles\n"
" * instead of scanlines. Different ways of organizing pixel within/across "
"tiles\n"
" * can be selected with the eTileOrganization parameter.\n"
" *\n"
" * If nXSize is not a multiple of nTileXSize or nYSize is not a multiple of\n"
" * nTileYSize, partial tiles will exists at the right and/or bottom of the "
"region\n"
" * of interest. Those partial tiles will also have nTileXSize * nTileYSize "
"dimension,\n"
" * with padding pixels.\n"
" *\n"
" * The pointer to access the virtual memory object is obtained with\n"
" * CPLVirtualMemGetAddr(). It remains valid until CPLVirtualMemFree() is "
"called.\n"
" * CPLVirtualMemFree() must be called before the dataset object is "
"destroyed.\n"
" *\n"
" * If p is such a pointer and base_type the C type matching eBufType, for "
"default\n"
" * values of spacing parameters, the element of image coordinates (x, y)\n"
" * (relative to xOff, yOff) for band b can be accessed with :\n"
" *  - for eTileOrganization = GTO_TIP, ((base_type*)p)[tile_number(x,"
"y)*nBandCount*tile_size + offset_in_tile(x,y)*nBandCount + (b-1)].\n"
" *  - for eTileOrganization = GTO_BIT, ((base_type*)p)[(tile_number(x,"
"y)*nBandCount + (b-1)) * tile_size + offset_in_tile(x,y)].\n"
" *  - for eTileOrganization = GTO_BSQ, ((base_type*)p)[(tile_number(x,y) + "
"(b-1)*nTilesCount) * tile_size + offset_in_tile(x,y)].\n"
" *\n"
" * where nTilesPerRow = ceil(nXSize / nTileXSize)\n"
" *       nTilesPerCol = ceil(nYSize / nTileYSize)\n"
" *       nTilesCount = nTilesPerRow * nTilesPerCol\n"
" *       tile_number(x,y) = (y / nTileYSize) * nTilesPerRow + (x / "
"nTileXSize)\n"
" *       offset_in_tile(x,y) = (y % nTileYSize) * nTileXSize  + (x % "
"nTileXSize)\n"
" *       tile_size = nTileXSize * nTileYSize\n"
" *\n"
" * Note that for a single band request, all tile organizations are "
"equivalent.\n"
" *\n"
" * Note that the mechanism used to transparently fill memory pages when they "
"are\n"
" * accessed is the same (but in a controlled way) than what occurs when a "
"memory\n"
" * error occurs in a program. Debugging software will generally interrupt "
"program\n"
" * execution when that happens. If needed, CPLVirtualMemPin() can be used to "
"avoid\n"
" * that by ensuring memory pages are allocated before being accessed.\n"
" *\n"
" * The size of the region that can be mapped as a virtual memory object "
"depends\n"
" * on hardware and operating system limitations.\n"
" * On Linux AMD64 platforms, the maximum value is 128 TB.\n"
" * On Linux x86 platforms, the maximum value is 2 GB.\n"
" *\n"
" * Data type translation is automatically done if the data type\n"
" * (eBufType) of the buffer is different than\n"
" * that of the GDALRasterBand.\n"
" *\n"
" * @param hDS Dataset object\n"
" *\n"
" * @param eRWFlag Either GF_Read to read a region of data, or GF_Write to\n"
" * write a region of data.\n"
" *\n"
" * @param nXOff The pixel offset to the top left corner of the region\n"
" * of the band to be accessed.  This would be zero to start from the left "
"side.\n"
" *\n"
" * @param nYOff The line offset to the top left corner of the region\n"
" * of the band to be accessed.  This would be zero to start from the top.\n"
" *\n"
" * @param nXSize The width of the region of the band to be accessed in "
"pixels.\n"
" *\n"
" * @param nYSize The height of the region of the band to be accessed in "
"lines.\n"
" *\n"
" * @param nTileXSize the width of the tiles.\n"
" *\n"
" * @param nTileYSize the height of the tiles.\n"
" *\n"
" * @param eBufType the type of the pixel values in the data buffer. The\n"
" * pixel values will automatically be translated to/from the GDALRasterBand\n"
" * data type as needed.\n"
" *\n"
" * @param nBandCount the number of bands being read or written.\n"
" *\n"
" * @param panBandMap the list of nBandCount band numbers being read/"
"written.\n"
" * Note band numbers are 1 based. This may be NULL to select the first\n"
" * nBandCount bands.\n"
" *\n"
" * @param eTileOrganization tile organization.\n"
" *\n"
" * @param nCacheSize   size in bytes of the maximum memory that will be "
"really\n"
" *                     allocated (must ideally fit into RAM)\n"
" *\n"
" * @param bSingleThreadUsage set to TRUE if there will be no concurrent "
"threads\n"
" *                           that will access the virtual memory mapping. "
"This can\n"
" *                           optimize performance a bit. If set to FALSE,\n"
" *                           CPLVirtualMemDeclareThread() must be called.\n"
" *\n"
" * @param papszOptions NULL terminated list of options. Unused for now.\n"
" *\n"
" * @return a virtual memory object that must be freed by "
"CPLVirtualMemFree(),\n"
" *         or NULL in case of failure.\n"
" *\n"
" * @since GDAL 1.11\n"
" */\n"
"\n"
"CPLVirtualMem CPL_DLL* GDALDatasetGetTiledVirtualMem( GDALDatasetH hDS,\n"
"                                              GDALRWFlag eRWFlag,\n"
"                                              int nXOff, int nYOff,\n"
"                                              int nXSize, int nYSize,\n"
"                                              int nTileXSize, int "
"nTileYSize,\n"
"                                              GDALDataType eBufType,\n"
"                                              int nBandCount, int* "
"panBandMap,\n"
"                                              GDALTileOrganization "
"eTileOrganization,\n"
"                                              size_t nCacheSize,\n"
"                                              int bSingleThreadUsage,\n"
"                                              char **papszOptions );\n"
"\n"
"/** Create a CPLVirtualMem object from a GDAL rasterband object, with "
"tiling\n"
" * organization\n"
" *\n"
" * Only supported on Linux for now.\n"
" *\n"
" * This method allows creating a virtual memory object for a region of one\n"
" * GDALRasterBand. The content of the virtual\n"
" * memory object is automatically filled from dataset content when a "
"virtual\n"
" * memory page is first accessed, and it is released (or flushed in case of "
"a\n"
" * \"dirty\" page) when the cache size limit has been reached.\n"
" *\n"
" * Contrary to GDALDatasetGetVirtualMem(), pixels will be organized by "
"tiles\n"
" * instead of scanlines.\n"
" *\n"
" * If nXSize is not a multiple of nTileXSize or nYSize is not a multiple of\n"
" * nTileYSize, partial tiles will exists at the right and/or bottom of the "
"region\n"
" * of interest. Those partial tiles will also have nTileXSize * nTileYSize "
"dimension,\n"
" * with padding pixels.\n"
" *\n"
" * The pointer to access the virtual memory object is obtained with\n"
" * CPLVirtualMemGetAddr(). It remains valid until CPLVirtualMemFree() is "
"called.\n"
" * CPLVirtualMemFree() must be called before the raster band object is "
"destroyed.\n"
" *\n"
" * If p is such a pointer and base_type the C type matching eBufType, for "
"default\n"
" * values of spacing parameters, the element of image coordinates (x, y)\n"
" * (relative to xOff, yOff) can be accessed with :\n"
" *  ((base_type*)p)[tile_number(x,y)*tile_size + offset_in_tile(x,y)].\n"
" *\n"
" * where nTilesPerRow = ceil(nXSize / nTileXSize)\n"
" *       nTilesCount = nTilesPerRow * nTilesPerCol\n"
" *       tile_number(x,y) = (y / nTileYSize) * nTilesPerRow + (x / "
"nTileXSize)\n"
" *       offset_in_tile(x,y) = (y % nTileYSize) * nTileXSize  + (x % "
"nTileXSize)\n"
" *       tile_size = nTileXSize * nTileYSize\n"
" *\n"
" * Note that the mechanism used to transparently fill memory pages when they "
"are\n"
" * accessed is the same (but in a controlled way) than what occurs when a "
"memory\n"
" * error occurs in a program. Debugging software will generally interrupt "
"program\n"
" * execution when that happens. If needed, CPLVirtualMemPin() can be used to "
"avoid\n"
" * that by ensuring memory pages are allocated before being accessed.\n"
" *\n"
" * The size of the region that can be mapped as a virtual memory object "
"depends\n"
" * on hardware and operating system limitations.\n"
" * On Linux AMD64 platforms, the maximum value is 128 TB.\n"
" * On Linux x86 platforms, the maximum value is 2 GB.\n"
" *\n"
" * Data type translation is automatically done if the data type\n"
" * (eBufType) of the buffer is different than\n"
" * that of the GDALRasterBand.\n"
" *\n"
" * @param hBand Rasterband object\n"
" *\n"
" * @param eRWFlag Either GF_Read to read a region of data, or GF_Write to\n"
" * write a region of data.\n"
" *\n"
" * @param nXOff The pixel offset to the top left corner of the region\n"
" * of the band to be accessed.  This would be zero to start from the left "
"side.\n"
" *\n"
" * @param nYOff The line offset to the top left corner of the region\n"
" * of the band to be accessed.  This would be zero to start from the top.\n"
" *\n"
" * @param nXSize The width of the region of the band to be accessed in "
"pixels.\n"
" *\n"
" * @param nYSize The height of the region of the band to be accessed in "
"lines.\n"
" *\n"
" * @param nTileXSize the width of the tiles.\n"
" *\n"
" * @param nTileYSize the height of the tiles.\n"
" *\n"
" * @param eBufType the type of the pixel values in the data buffer. The\n"
" * pixel values will automatically be translated to/from the GDALRasterBand\n"
" * data type as needed.\n"
" *\n"
" * @param nCacheSize   size in bytes of the maximum memory that will be "
"really\n"
" *                     allocated (must ideally fit into RAM)\n"
" *\n"
" * @param bSingleThreadUsage set to TRUE if there will be no concurrent "
"threads\n"
" *                           that will access the virtual memory mapping. "
"This can\n"
" *                           optimize performance a bit. If set to FALSE,\n"
" *                           CPLVirtualMemDeclareThread() must be called.\n"
" *\n"
" * @param papszOptions NULL terminated list of options. Unused for now.\n"
" *\n"
" * @return a virtual memory object that must be freed by "
"CPLVirtualMemFree(),\n"
" *         or NULL in case of failure.\n"
" *\n"
" * @since GDAL 1.11\n"
" */\n"
"\n"
"CPLVirtualMem CPL_DLL* GDALRasterBandGetTiledVirtualMem( GDALRasterBandH "
"hBand,\n"
"                                              GDALRWFlag eRWFlag,\n"
"                                              int nXOff, int nYOff,\n"
"                                              int nXSize, int nYSize,\n"
"                                              int nTileXSize, int "
"nTileYSize,\n"
"                                              GDALDataType eBufType,\n"
"                                              size_t nCacheSize,\n"
"                                              int bSingleThreadUsage,\n"
"                                              char **papszOptions );"
msgstr ""

#: ../../../source/development/rfc/rfc45_virtualmem.rst:972
msgid "Implemented by gdalrasterband.cpp"
msgstr ""

#: ../../../source/development/rfc/rfc45_virtualmem.rst:977
msgid ""
"/** \\brief Create a CPLVirtualMem object from a GDAL raster band object.\n"
" *\n"
" * Only supported on Linux for now.\n"
" *\n"
" * This method allows creating a virtual memory object for a "
"GDALRasterBand,\n"
" * that exposes the whole image data as a virtual array.\n"
" *\n"
" * The default implementation relies on GDALRasterBandGetVirtualMem(), but "
"specialized\n"
" * implementation, such as for raw files, may also directly use mechanisms "
"of the\n"
" * operating system to create a view of the underlying file into virtual "
"memory\n"
" * ( CPLVirtualMemFileMapNew() )\n"
" *\n"
" * At the time of writing, the GeoTIFF driver and \"raw\" drivers "
"(EHdr, ...) offer\n"
" * a specialized implementation with direct file mapping, provided that "
"some\n"
" * requirements are met :\n"
" *   - for all drivers, the dataset must be backed by a \"real\" file in the "
"file\n"
" *     system, and the byte ordering of multi-byte datatypes (Int16, etc.)\n"
" *     must match the native ordering of the CPU.\n"
" *   - in addition, for the GeoTIFF driver, the GeoTIFF file must be "
"uncompressed, scanline\n"
" *     oriented (i.e. not tiled). Strips must be organized in the file in "
"sequential\n"
" *     order, and be equally spaced (which is generally the case). Only "
"power-of-two\n"
" *     bit depths are supported (8 for GDT_Bye, 16 for GDT_Int16/"
"GDT_UInt16,\n"
" *     32 for GDT_Float32 and 64 for GDT_Float64)\n"
" *\n"
" * The pointer returned remains valid until CPLVirtualMemFree() is called.\n"
" * CPLVirtualMemFree() must be called before the raster band object is "
"destroyed.\n"
" *\n"
" * If p is such a pointer and base_type the type matching "
"GDALGetRasterDataType(),\n"
" * the element of image coordinates (x, y) can be accessed with\n"
" * *(base_type*) ((GByte*)p + x * *pnPixelSpace + y * *pnLineSpace)\n"
" *\n"
" * This method is the same as the C GDALGetVirtualMemAuto() function.\n"
" *\n"
" * @param eRWFlag Either GF_Read to read the band, or GF_Write to\n"
" * read/write the band.\n"
" *\n"
" * @param pnPixelSpace Output parameter giving the byte offset from the "
"start of one pixel value in\n"
" * the buffer to the start of the next pixel value within a scanline.\n"
" *\n"
" * @param pnLineSpace Output parameter giving the byte offset from the start "
"of one scanline in\n"
" * the buffer to the start of the next.\n"
" *\n"
" * @param papszOptions NULL terminated list of options.\n"
" *                     If a specialized implementation exists, defining "
"USE_DEFAULT_IMPLEMENTATION=YES\n"
" *                     will cause the default implementation to be used.\n"
" *                     When requiring or falling back to the default "
"implementation, the following\n"
" *                     options are available : CACHE_SIZE (in bytes, "
"defaults to 40 MB),\n"
" *                     PAGE_SIZE_HINT (in bytes),\n"
" *                     SINGLE_THREAD (\"FALSE\" / \"TRUE\", defaults to "
"FALSE)\n"
" *\n"
" * @return a virtual memory object that must be unreferenced by "
"CPLVirtualMemFree(),\n"
" *         or NULL in case of failure.\n"
" *\n"
" * @since GDAL 1.11\n"
" */\n"
"\n"
"CPLVirtualMem  *GDALRasterBand::GetVirtualMemAuto( GDALRWFlag eRWFlag,\n"
"                                                   int *pnPixelSpace,\n"
"                                                   GIntBig *pnLineSpace,\n"
"                                                   char **papszOptions ):\n"
"\n"
"CPLVirtualMem CPL_DLL* GDALGetVirtualMemAuto( GDALRasterBandH hBand,\n"
"                                              GDALRWFlag eRWFlag,\n"
"                                              int *pnPixelSpace,\n"
"                                              GIntBig *pnLineSpace,\n"
"                                              char **papszOptions );"
msgstr ""

#: ../../../source/development/rfc/rfc45_virtualmem.rst:1045
msgid "Portability"
msgstr ""

#: ../../../source/development/rfc/rfc45_virtualmem.rst:1047
msgid ""
"The CPLVirtualMem low-level machinery is only implemented for Linux now. It "
"assumes that returning from a SIGSEGV handler is possible, which is a "
"blatant violation of POSIX, but in practice it seems that most POSIX (and "
"non POSIX such as Windows) systems should be able to resume execution after "
"a segmentation fault."
msgstr ""

#: ../../../source/development/rfc/rfc45_virtualmem.rst:1053
msgid ""
"Porting to other POSIX operating systems such as MacOSX should be doable "
"with moderate effort. Windows has API that offer similar capabilities as "
"POSIX API with VirtualAlloc(), VirtualProtect() and "
"SetUnhandledExceptionFilter(), although the porting would undoubtly require "
"more effort."
msgstr ""

#: ../../../source/development/rfc/rfc45_virtualmem.rst:1059
msgid ""
"The existence of `libsigsegv <http://www.gnu.org/software/libsigsegv>`__ "
"that run on various OS is an evidence on its capacity of being ported to "
"other platforms."
msgstr ""

#: ../../../source/development/rfc/rfc45_virtualmem.rst:1063
msgid ""
"The trickiest part is ensuring that things will work reliably when two "
"concurrent threads that try to access the same initially unmapped page. "
"Without special care, one thread could manage to access the page that is "
"being filled by the other thread, before it is completely filled. On Linux "
"this can be easily avoided with the mremap() call. When a page is filled, we "
"don't actually pass the target page to the user callback, but a temporary "
"page. When the callback has finished its job, this temporary page is "
"mremap()'ed to its target location, which is an atomic operation. An "
"alternative implementation for POSIX systems that don't have this mremap() "
"call has been tested : any declared threads that can access the memory "
"mapping are paused before the temporary page is memcpy'ed to its target "
"location, and are resumed afterwards. This requires threads to priorly "
"declare their \"interest\" for a memory mapping with "
"CPLVirtualMemDeclareThread(). Pausing a thread is interestingly non-"
"obvious : the solution found to do so is to send it a SIGUSR1 signal and "
"make it wait in a signal handler for this SIGUSR1 signal... It has not been "
"investigated if/how this could be done on Windows. "
"CPLVirtualMemIsAccessThreadSafe() has been introduced for that purpose."
msgstr ""

#: ../../../source/development/rfc/rfc45_virtualmem.rst:1083
msgid ""
"As far as CPLVirtualMemFileMapNew() is concerned, memory file mapping on "
"POSIX systems with mmap() should be portable. Windows has "
"CreateFileMapping() and MapViewOfFile() API that have similar capabilities "
"as mmap()."
msgstr ""

#: ../../../source/development/rfc/rfc45_virtualmem.rst:1089
msgid "Performance"
msgstr ""

#: ../../../source/development/rfc/rfc45_virtualmem.rst:1091
msgid ""
"No miraculous performance gain should be expected from this new capability, "
"when compared to code that carefully uses GDALRasterIO(). Handling "
"segmentation faults has a cost ( the operating system catches a hardware "
"exception, then calls the user program segmentation fault handler, which "
"does the normal GDAL I/O operations, and plays with page mappings and "
"permissions which invalidate some CPU caches, etc... ). However, when a page "
"has been realized, access to it should be really fast, so with appropriate "
"access patterns and cache size, good performance should be expected."
msgstr ""

#: ../../../source/development/rfc/rfc45_virtualmem.rst:1101
msgid ""
"It should also be noted that in the current implementation, the realization "
"of pages is done in a serialized way, that is to say if 2 threads which use "
"2 different memory mappings cause a segmentation fault at the same time, "
"they will not be dealt by 2 different threads, but one after the other one."
msgstr ""

#: ../../../source/development/rfc/rfc45_virtualmem.rst:1107
msgid ""
"The overhead of virtual memory objects returned by GetVirtualMemAuto(), when "
"using the memory file mapping, should be lesser than the manual management "
"of page faults. However, GDAL has no control of the strategy used by the "
"operating system to cache pages."
msgstr ""

#: ../../../source/development/rfc/rfc45_virtualmem.rst:1113
msgid "Limitations"
msgstr ""

#: ../../../source/development/rfc/rfc45_virtualmem.rst:1115
msgid ""
"The maximum size of the virtual memory space (and thus a virtual memory "
"mapping) depends on the CPU architecture and OS limitations :"
msgstr ""

#: ../../../source/development/rfc/rfc45_virtualmem.rst:1118
msgid "on Linux AMD64, 128 TB."
msgstr ""

#: ../../../source/development/rfc/rfc45_virtualmem.rst:1119
msgid "on Linux x86, 2 GB."
msgstr ""

#: ../../../source/development/rfc/rfc45_virtualmem.rst:1120
msgid "On Windows AMD64 (unsupported by the current implementation), 8 TB."
msgstr ""

#: ../../../source/development/rfc/rfc45_virtualmem.rst:1121
msgid "On Windows x86 (unsupported by the current implementation), 2 GB."
msgstr ""

#: ../../../source/development/rfc/rfc45_virtualmem.rst:1123
msgid ""
"Clearly, the main interest of this new functionality is for AMD64 platforms."
msgstr ""

#: ../../../source/development/rfc/rfc45_virtualmem.rst:1126
msgid ""
"On a Linux AMD64 machine with 4 GB RAM, the Python binding of "
"GDALDatasetGetTiledVirtualMem() has been successfully used to access random "
"points on the new `Europe 3'' DEM dataset <http://www.eea.europa.eu/data-and-"
"maps/data/eu-dem/#tab-original-data>`__, which is a 20 GB compressed GeoTIFF "
"( and 288000 \\* 180000 \\* 4 = 193 GB uncompressed )"
msgstr ""

#: ../../../source/development/rfc/rfc45_virtualmem.rst:1134
msgid "Related thoughts"
msgstr ""

#: ../../../source/development/rfc/rfc45_virtualmem.rst:1136
msgid ""
"Some issues with system calls such as read() or write(), or easier multi-"
"threading could potentially be solved by making a FUSE (File system in USEr "
"space) driver that would expose a GDAL dataset as a file, and the mmap()'ing "
"the file itself. However FUSE drivers are only available on POSIX OS, and "
"need root privilege to be mounted (a FUSE filesystem does not need root "
"privilege to run, but the mounting operation does)."
msgstr ""

#: ../../../source/development/rfc/rfc45_virtualmem.rst:1145
msgid "Open questions"
msgstr ""

#: ../../../source/development/rfc/rfc45_virtualmem.rst:1147
msgid ""
"Due to the fact that it currently only works on Linux, should we mark the "
"API as experimental for now ?"
msgstr ""

#: ../../../source/development/rfc/rfc45_virtualmem.rst:1151
msgid "Backward compatibility issues"
msgstr ""

#: ../../../source/development/rfc/rfc45_virtualmem.rst:1153
msgid ""
"C/C++ API --> compatible (new API). C ABI --> compatible (new API). C++ ABI "
"--> incompatibility because GDALRasterBand has a new virtual method."
msgstr ""

#: ../../../source/development/rfc/rfc45_virtualmem.rst:1157
msgid "Updated drivers"
msgstr ""

#: ../../../source/development/rfc/rfc45_virtualmem.rst:1159
msgid ""
"The RawRasterBand object and GeoTIFF drivers will be updated to implement "
"GetVirtualMemAuto() and offer memory file mapping when possible (see above "
"documented restrictions on when this is possible)."
msgstr ""

#: ../../../source/development/rfc/rfc45_virtualmem.rst:1163
msgid ""
"In future steps, other drivers such as the VRT driver (for VRTRawRasterBand) "
"could also offer a specialized implementation of GetVirtualMemAuto()."
msgstr ""

#: ../../../source/development/rfc/rfc45_virtualmem.rst:1168
msgid "SWIG bindings"
msgstr ""

#: ../../../source/development/rfc/rfc45_virtualmem.rst:1170
msgid ""
"The high level API (dataset and raster band) API is available in Python "
"bindings."
msgstr ""

#: ../../../source/development/rfc/rfc45_virtualmem.rst:1173
msgid ""
"GDALDatasetGetVirtualMem() is mapped as Dataset.GetVirtualArray(), which "
"returns a NumPy array."
msgstr ""

#: ../../../source/development/rfc/rfc45_virtualmem.rst:1178
msgid ""
"def GetVirtualMemArray(self, eAccess = gdalconst.GF_Read, xoff=0, yoff=0,\n"
"                       xsize=None, ysize=None, bufxsize=None, "
"bufysize=None,\n"
"                       datatype = None, band_list = None, band_sequential = "
"True,\n"
"                       cache_size = 10 * 1024 * 1024, page_size_hint = 0, "
"options = None):\n"
"    \"\"\"Return a NumPy array for the dataset, seen as a virtual memory "
"mapping.\n"
"       If there are several bands and band_sequential = True, an element is\n"
"       accessed with array[band][y][x].\n"
"       If there are several bands and band_sequential = False, an element "
"is\n"
"       accessed with array[y][x][band].\n"
"       If there is only one band, an element is accessed with array[y][x].\n"
"       Any reference to the array must be dropped before the last reference "
"to the\n"
"       related dataset is also dropped.\n"
"    \"\"\""
msgstr ""

#: ../../../source/development/rfc/rfc45_virtualmem.rst:1192
msgid "Similarly for GDALDatasetGetTiledVirtualMem() :"
msgstr ""

#: ../../../source/development/rfc/rfc45_virtualmem.rst:1196
msgid ""
"def GetTiledVirtualMemArray(self, eAccess = gdalconst.GF_Read, xoff=0, "
"yoff=0,\n"
"                       xsize=None, ysize=None, tilexsize=256, "
"tileysize=256,\n"
"                       datatype = None, band_list = None, tile_organization "
"= gdalconst.GTO_BSQ,\n"
"                       cache_size = 10 * 1024 * 1024, options = None):\n"
"    \"\"\"Return a NumPy array for the dataset, seen as a virtual memory "
"mapping with\n"
"       a tile organization.\n"
"       If there are several bands and tile_organization = gdal.GTO_BIP, an "
"element is\n"
"       accessed with array[tiley][tilex][y][x][band].\n"
"       If there are several bands and tile_organization = gdal.GTO_BTI, an "
"element is\n"
"       accessed with array[tiley][tilex][band][y][x].\n"
"       If there are several bands and tile_organization = gdal.GTO_BSQ, an "
"element is\n"
"       accessed with array[band][tiley][tilex][y][x].\n"
"       If there is only one band, an element is accessed with array[tiley]"
"[tilex][y][x].\n"
"       Any reference to the array must be dropped before the last reference "
"to the\n"
"       related dataset is also dropped.\n"
"    \"\"\""
msgstr ""

#: ../../../source/development/rfc/rfc45_virtualmem.rst:1213
msgid "And the Band object has the following 3 methods :"
msgstr ""

#: ../../../source/development/rfc/rfc45_virtualmem.rst:1217
msgid ""
"def GetVirtualMemArray(self, eAccess = gdalconst.GF_Read, xoff=0, yoff=0,\n"
"                       xsize=None, ysize=None, bufxsize=None, "
"bufysize=None,\n"
"                       datatype = None,\n"
"                       cache_size = 10 * 1024 * 1024, page_size_hint = 0, "
"options = None):\n"
"      \"\"\"Return a NumPy array for the band, seen as a virtual memory "
"mapping.\n"
"         An element is accessed with array[y][x].\n"
"         Any reference to the array must be dropped before the last "
"reference to the\n"
"         related dataset is also dropped.\n"
"      \"\"\"\n"
"\n"
"def GetVirtualMemAutoArray(self, eAccess = gdalconst.GF_Read, options = "
"None):\n"
"      \"\"\"Return a NumPy array for the band, seen as a virtual memory "
"mapping.\n"
"         An element is accessed with array[y][x].\n"
"      \"\"\"\n"
"\n"
"def GetTiledVirtualMemArray(self, eAccess = gdalconst.GF_Read, xoff=0, "
"yoff=0,\n"
"                         xsize=None, ysize=None, tilexsize=256, "
"tileysize=256,\n"
"                         datatype = None,\n"
"                         cache_size = 10 * 1024 * 1024, options = None):\n"
"      \"\"\"Return a NumPy array for the band, seen as a virtual memory "
"mapping with\n"
"         a tile organization.\n"
"         An element is accessed with array[tiley][tilex][y][x].\n"
"         Any reference to the array must be dropped before the last "
"reference to the\n"
"         related dataset is also dropped.\n"
"      \"\"\""
msgstr ""

#: ../../../source/development/rfc/rfc45_virtualmem.rst:1243
msgid ""
"Note: dataset/Band.GetVirtualMem()/GetTiledVirtualMem() methods are also "
"available. They return a VirtualMem python object that has a GetAddr() "
"method that returns a Python memoryview object (Python 2.7 or later "
"required). However, using such object does not seem practical for non-Byte "
"data types."
msgstr ""

#: ../../../source/development/rfc/rfc45_virtualmem.rst:1250
msgid "Test Suite"
msgstr ""

#: ../../../source/development/rfc/rfc45_virtualmem.rst:1252
msgid ""
"The autotest suite will be extended to test the Python API of this RFC. It "
"will also test the specialized implementations of GetVirtualMemAuto() in "
"RawRasterBand and the GeoTIFF drivers. In autotest/cpp, a test_virtualmem."
"cpp file tests concurrent access to the same pages by 2 threads."
msgstr ""

#: ../../../source/development/rfc/rfc45_virtualmem.rst:1259
msgid "Implementation"
msgstr ""

#: ../../../source/development/rfc/rfc45_virtualmem.rst:1261
msgid ""
"Implementation will be done by Even Rouault in GDAL/OGR trunk. The proposed "
"implementation is attached as a `patch <http://trac.osgeo.org/gdal/"
"attachment/wiki/rfc45_virtualmem/virtualmem.patch>`__."
msgstr ""

#: ../../../source/development/rfc/rfc45_virtualmem.rst:1266
msgid "Voting history"
msgstr ""

#: ../../../source/development/rfc/rfc45_virtualmem.rst:1268
msgid "+1 from EvenR, FrankW, DanielM and JukkaR"
msgstr ""
