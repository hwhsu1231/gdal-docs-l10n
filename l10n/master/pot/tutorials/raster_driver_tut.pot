# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1998-2024
# This file is distributed under the same license as the GDAL package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: GDAL master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-06-26 10:24+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../source/tutorials/raster_driver_tut.rst:5
msgid "Raster driver implementation tutorial"
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:10
msgid "Overall Approach"
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:12
msgid ""
"In general new formats are added to GDAL by implementing format specific "
"drivers as subclasses of :cpp:class:`GDALDataset`, and band accessors as "
"subclasses of :cpp:class:`GDALRasterBand`. As well, a :cpp:class:"
"`GDALDriver` instance is created for the format, and registered with the :"
"cpp:class:`GDALDriverManager`, to ensure that the system knows about the "
"format."
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:14
msgid ""
"This tutorial will start with implementing a simple read-only driver (based "
"on the JDEM driver), and then proceed to utilizing the RawRasterBand helper "
"class, implementing creatable and updatable formats, and some esoteric "
"issues."
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:16
msgid ""
"It is strongly advised that the :ref:`raster_data_model` be reviewed and "
"understood before attempting to implement a GDAL driver."
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:19
msgid "Implementing the Dataset"
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:21
msgid ""
"We will start showing minimal implementation of a read-only driver for the "
"Japanese DEM format (:source_file:`frmts/jdem/jdemdataset.cpp`). First we "
"declare a format specific dataset class, JDEMDataset in this case."
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:23
msgid ""
"class JDEMDataset final: public GDALPamDataset\n"
"{\n"
"    friend class JDEMRasterBand;\n"
"\n"
"    VSILFILE           *m_fp = nullptr;\n"
"    GByte               m_abyHeader[HEADER_SIZE];\n"
"    OGRSpatialReference m_oSRS{};\n"
"\n"
"  public:\n"
"                     JDEMDataset();\n"
"                    ~JDEMDataset();\n"
"\n"
"    static GDALDataset *Open( GDALOpenInfo * );\n"
"    static int Identify( GDALOpenInfo * );\n"
"\n"
"    CPLErr GetGeoTransform( double * padfTransform ) override;\n"
"    const OGRSpatialReference* GetSpatialRef() const override;\n"
"};"
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:44
msgid ""
"In general we provide capabilities for a driver, by overriding the various "
"virtual methods on the GDALDataset base class. However, the Open() method is "
"special. This is not a virtual method on the base class, and we will need a "
"freestanding function for this operation, so we declare it static. "
"Implementing it as a method in the JDEMDataset class is convenient because "
"we have privileged access to modify the contents of the database object."
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:46
msgid "The open method itself may look something like this:"
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:48
msgid ""
"GDALDataset *JDEMDataset::Open( GDALOpenInfo *poOpenInfo )\n"
"{\n"
"    // Confirm that the header is compatible with a JDEM dataset.\n"
"    if (!Identify(poOpenInfo))\n"
"        return nullptr;\n"
"\n"
"    // Confirm the requested access is supported.\n"
"    if( poOpenInfo->eAccess == GA_Update )\n"
"    {\n"
"        CPLError(CE_Failure, CPLE_NotSupported,\n"
"                 \"The JDEM driver does not support update access to "
"existing \"\n"
"                 \"datasets.\");\n"
"        return nullptr;\n"
"    }\n"
"\n"
"    // Check that the file pointer from GDALOpenInfo* is available.\n"
"    if( poOpenInfo->fpL == nullptr )\n"
"    {\n"
"        return nullptr;\n"
"    }\n"
"\n"
"    // Create a corresponding GDALDataset.\n"
"    auto poDS = cpl::make_unique<JDEMDataset>();\n"
"\n"
"    // Borrow the file pointer from GDALOpenInfo*.\n"
"    std::swap(poDS->m_fp, poOpenInfo->fpL);\n"
"\n"
"    // Store the header (we have already checked it is at least HEADER_SIZE\n"
"    // byte large).\n"
"    memcpy(poDS->m_abyHeader, poOpenInfo->pabyHeader, HEADER_SIZE);\n"
"\n"
"    const char *psHeader = reinterpret_cast<const char *>(poDS-"
">m_abyHeader);\n"
"    poDS->nRasterXSize = JDEMGetField(psHeader + 23, 3);\n"
"    poDS->nRasterYSize = JDEMGetField(psHeader + 26, 3);\n"
"    if( !GDALCheckDatasetDimensions(poDS->nRasterXSize, poDS-"
">nRasterYSize) )\n"
"    {\n"
"        return nullptr;\n"
"    }\n"
"\n"
"    // Create band information objects.\n"
"    poDS->SetBand(1, new JDEMRasterBand(poDS.get(), 1));\n"
"\n"
"    // Initialize any PAM information.\n"
"    poDS->SetDescription(poOpenInfo->pszFilename);\n"
"    poDS->TryLoadXML();\n"
"\n"
"    // Check for overviews.\n"
"    poDS->oOvManager.Initialize(poDS.get(), poOpenInfo->pszFilename);\n"
"\n"
"    return poDS.release();\n"
"}"
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:102
msgid ""
"The first step in any database Open function is to verify that the file "
"being passed is in fact of the type this driver is for.  It is important to "
"realize that each driver's Open function is called in turn till one "
"succeeds.  Drivers must quietly return nullptr if the passed file is not of "
"their format.  They should only produce an error if the file does appear to "
"be of their supported format, but is for some reason unsupported or corrupt. "
"The information on the file to be opened is passed in contained in a "
"GDALOpenInfo object.  The GDALOpenInfo includes the following public data "
"members:"
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:112
msgid ""
"char        *pszFilename;\n"
"char**      papszOpenOptions;\n"
"GDALAccess  eAccess;  // GA_ReadOnly or GA_Update\n"
"int         nOpenFlags;\n"
"int         bStatOK;\n"
"int         bIsDirectory;\n"
"VSILFILE   *fpL;\n"
"int         nHeaderBytes;\n"
"GByte       *pabyHeader;"
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:124
msgid ""
"The driver can inspect these to establish if the file is supported. If the "
"`pszFilename` refers to an object in the file system, the `bStatOK` flag "
"will be set to TRUE. As well, if the file was successfully opened, the first "
"kilobyte or so is read in, and put in pabyHeader, with the exact size in "
"`nHeaderBytes`."
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:126
msgid ""
"In this typical testing example it is verified that the file was "
"successfully opened, that we have at least enough header information to "
"perform our test, and that various parts of the header are as expected for "
"this format. In this case, there are no magic numbers for JDEM format so we "
"check various date fields to ensure they have reasonable century values. If "
"the test fails, we quietly return NULL indicating this file isn't of our "
"supported format."
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:128
msgid ""
"The identification is in fact delegated to a Identify() static function :"
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:130
msgid ""
"/************************************************************************/\n"
"/*                              Identify()                              */\n"
"/************************************************************************/\n"
"int JDEMDataset::Identify( GDALOpenInfo * poOpenInfo )\n"
"{\n"
"    if( poOpenInfo->nHeaderBytes < HEADER_SIZE )\n"
"        return FALSE;\n"
"\n"
"    // Confirm that the header has what appears to be dates in the\n"
"    // expected locations.\n"
"    // Check if century values seem reasonable.\n"
"    const char *psHeader = reinterpret_cast<char *>(poOpenInfo-"
">pabyHeader);\n"
"    if( (!STARTS_WITH_CI(psHeader + 11, \"19\") &&\n"
"         !STARTS_WITH_CI(psHeader + 11, \"20\")) ||\n"
"        (!STARTS_WITH_CI(psHeader + 15, \"19\") &&\n"
"         !STARTS_WITH_CI(psHeader + 15, \"20\")) ||\n"
"        (!STARTS_WITH_CI(psHeader + 19, \"19\") &&\n"
"         !STARTS_WITH_CI(psHeader + 19, \"20\")) )\n"
"    {\n"
"        return FALSE;\n"
"    }\n"
"\n"
"    // Check the extent too. In particular, that we are in the first "
"quadrant,\n"
"    // as this is only for Japan.\n"
"    const double dfLLLat = JDEMGetAngle(psHeader + 29);\n"
"    const double dfLLLong = JDEMGetAngle(psHeader + 36);\n"
"    const double dfURLat = JDEMGetAngle(psHeader + 43);\n"
"    const double dfURLong = JDEMGetAngle(psHeader + 50);\n"
"    if( dfLLLat > 90 || dfLLLat < 0 ||\n"
"        dfLLLong > 180 ||dfLLLong < 0 ||\n"
"        dfURLat > 90 || dfURLat < 0 ||\n"
"        dfURLong > 180 || dfURLong < 0 ||\n"
"        dfLLLat > dfURLat ||\n"
"        dfLLLong > dfURLong )\n"
"    {\n"
"        return FALSE;\n"
"    }\n"
"\n"
"    return TRUE;\n"
"}"
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:173
msgid ""
"It is important to make the \"is this my format\" test as stringent as "
"possible.  In this particular case, we check that dates are in the 19th or "
"20th centry, but as this might also be too weak, we check that the "
"geospatial extent is consistent, and valid for Japan. Once we are satisfied "
"that the file is of our format, we can do any other tests that are necessary "
"to validate the file is usable, and in particular that we can provide the "
"level of access desired.  Since the JDEM driver does not provide update "
"support, error out in that case."
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:182
msgid ""
"if( poOpenInfo->eAccess == GA_Update )\n"
"{\n"
"    CPLError(CE_Failure, CPLE_NotSupported,\n"
"             \"The JDEM driver does not support update access to existing "
"\"\n"
"             \"datasets.\");\n"
"    return NULL;\n"
"}"
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:192
msgid ""
"Next we need to create an instance of the database class in which we will "
"set various information of interest. We create it as a std::"
"unique_ptr<JDEMDataset> with the cpl::make_unique<> utility (equivalent to "
"std::make_unique<> available in C++14 and later), to make memory management "
"easier in error code paths."
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:197
msgid ""
"// Check that the file pointer from GDALOpenInfo* is available.\n"
"if( poOpenInfo->fpL == NULL )\n"
"{\n"
"    return NULL;\n"
"}\n"
"auto poDS = cpl::make_unique<JDEMDataset>();\n"
"\n"
"// Borrow the file pointer from GDALOpenInfo*.\n"
"std::swap(poDS->m_fp, poOpenInfo->fpL);"
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:209
msgid ""
"At this point we \"borrow\" the file handle that was held by GDALOpenInfo* "
"(we did make sure that poDS->m_fp is initialized to nullptr in the inline "
"member definition). This file pointer uses the VSI*L GDAL API to access "
"files on disk. This virtualized POSIX-style API allows some special "
"capabilities like supporting large files, in-memory files and zipped files."
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:213
msgid ""
"Next the X and Y size are extracted from the header. The `nRasterXSize` and "
"`nRasterYSize` are data fields inherited from the GDALDataset base class, "
"and must be set by the Open() method."
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:215
msgid ""
"// Store the header (we have already checked it is at least HEADER_SIZE\n"
"// byte large).\n"
"memcpy(poDS->m_abyHeader, poOpenInfo->pabyHeader, HEADER_SIZE);\n"
"\n"
"const char *psHeader = reinterpret_cast<const char *>(poDS->m_abyHeader);\n"
"poDS->nRasterXSize = JDEMGetField(psHeader + 23, 3);\n"
"poDS->nRasterYSize = JDEMGetField(psHeader + 26, 3);\n"
"if( !GDALCheckDatasetDimensions(poDS->nRasterXSize, poDS->nRasterYSize) )\n"
"{\n"
"    return nullptr;\n"
"}"
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:230
msgid ""
"All the bands related to this dataset must be created and attached using the "
"SetBand() method. We will explore the JDEMRasterBand() class shortly."
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:232
msgid ""
"// Create band information objects.\n"
"poDS->SetBand(1, new JDEMRasterBand(poDS.get(), 1));"
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:237
msgid ""
"Finally we assign a name to the dataset object, and call the GDALPamDataset "
"TryLoadXML() method which can initialize auxiliary information from an .aux."
"xml file if available. We also initialize for external overviews (in a .ovr "
"side car file). For more details on these services review the GDALPamDataset "
"and related classes."
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:240
msgid ""
"    // Initialize any PAM information.\n"
"    poDS->SetDescription( poOpenInfo->pszFilename );\n"
"    poDS->TryLoadXML();\n"
"\n"
"    // Check for overviews.\n"
"    poDS->oOvManager.Initialize(poDS.get(), poOpenInfo->pszFilename);\n"
"\n"
"    return poDS.release();\n"
"}"
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:253
msgid "Implementing the RasterBand"
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:255
msgid ""
"Similar to the customized JDEMDataset class subclassed from GDALDataset, we "
"also need to declare and implement a customized JDEMRasterBand derived from :"
"cpp:class:`GDALRasterBand` for access to the band(s) of the JDEM file. For "
"JDEMRasterBand the declaration looks like this:"
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:257
msgid ""
"class JDEMRasterBand final: public GDALPamRasterBand\n"
"{\n"
"    friend class JDEMDataset;\n"
"\n"
"    int          m_nRecordSize = 0;\n"
"    char        *m_pszRecord = nullptr;\n"
"    bool         m_bBufferAllocFailed = false;\n"
"\n"
"  public:\n"
"                JDEMRasterBand( JDEMDataset *, int );\n"
"               ~JDEMRasterBand();\n"
"\n"
"    virtual CPLErr IReadBlock( int, int, void * ) override;\n"
"};"
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:275
msgid ""
"The constructor may have any signature, and is only called from the Open() "
"method. Other virtual methods, such as :cpp:func:`GDALRasterBand::"
"IReadBlock` must be exactly matched to the method signature in gdal_priv.h."
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:277
msgid "The constructor implementation looks like this:"
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:279
msgid ""
"JDEMRasterBand::JDEMRasterBand( JDEMDataset *poDSIn, int nBandIn ) :\n"
"    // Cannot overflow as nBlockXSize <= 999.\n"
"    m_nRecordSize(poDSIn->GetRasterXSize() * 5 + 9 + 2)\n"
"{\n"
"    poDS = poDSIn;\n"
"    nBand = nBandIn;\n"
"\n"
"    eDataType = GDT_Float32;\n"
"\n"
"    nBlockXSize = poDS->GetRasterXSize();\n"
"    nBlockYSize = 1;\n"
"}"
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:294
msgid ""
"The following data members are inherited from GDALRasterBand, and should "
"generally be set in the band constructor."
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:296
msgid ""
"poDS: Pointer to the parent GDALDataset.\n"
"nBand: The band number within the dataset.\n"
"eDataType: The data type of pixels in this band.\n"
"nBlockXSize: The width of one block in this band.\n"
"nBlockYSize: The height of one block in this band."
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:304
msgid ""
"The full set of possible GDALDataType values are declared in gdal.h, and "
"include GDT_Byte, GDT_UInt16, GDT_Int16, and GDT_Float32. The block size is "
"used to establish a natural or efficient block size to access the data with. "
"For tiled datasets this will be the size of a tile, while for most other "
"datasets it will be one scanline, as in this case."
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:306
msgid ""
"Next we see the implementation of the code that actually reads the image "
"data, IReadBlock()."
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:308
msgid ""
"CPLErr JDEMRasterBand::IReadBlock( int /* nBlockXOff */,\n"
"                                   int nBlockYOff,\n"
"                                   void * pImage )\n"
"\n"
"{\n"
"    JDEMDataset *poGDS = cpl::down_cast<JDEMDataset *>(poDS);\n"
"\n"
"    if (m_pszRecord == nullptr)\n"
"    {\n"
"        if (m_bBufferAllocFailed)\n"
"            return CE_Failure;\n"
"\n"
"        m_pszRecord = static_cast<char "
"*>(VSI_MALLOC_VERBOSE(m_nRecordSize));\n"
"        if (m_pszRecord == nullptr)\n"
"        {\n"
"            m_bBufferAllocFailed = true;\n"
"            return CE_Failure;\n"
"        }\n"
"    }\n"
"\n"
"    CPL_IGNORE_RET_VAL(\n"
"        VSIFSeekL(poGDS->m_fp, 1011 + m_nRecordSize * nBlockYOff, "
"SEEK_SET));\n"
"\n"
"    if( VSIFReadL(m_pszRecord, m_nRecordSize, 1, poGDS->m_fp) != 1 )\n"
"    {\n"
"        CPLError(CE_Failure, CPLE_AppDefined,\n"
"                 \"Cannot read scanline %d\", nBlockYOff);\n"
"        return CE_Failure;\n"
"    }\n"
"\n"
"    if( !EQUALN(reinterpret_cast<char *>(poGDS->m_abyHeader), m_pszRecord, "
"6) )\n"
"    {\n"
"        CPLError(CE_Failure, CPLE_AppDefined,\n"
"                 \"JDEM Scanline corrupt.  Perhaps file was not transferred "
"\"\n"
"                 \"in binary mode?\");\n"
"        return CE_Failure;\n"
"    }\n"
"\n"
"    if( JDEMGetField(m_pszRecord + 6, 3) != nBlockYOff + 1 )\n"
"    {\n"
"        CPLError(CE_Failure, CPLE_AppDefined,\n"
"                 \"JDEM scanline out of order, JDEM driver does not \"\n"
"                 \"currently support partial datasets.\");\n"
"        return CE_Failure;\n"
"    }\n"
"\n"
"    for( int i = 0; i < nBlockXSize; i++ )\n"
"        static_cast<float *>(pImage)[i] =\n"
"            JDEMGetField(m_pszRecord + 9 + 5 * i, 5) * 0.1f;\n"
"\n"
"    return CE_None;\n"
"}"
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:363
msgid "Key items to note are:"
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:365
msgid ""
"It is typical to cast the GDALRasterBand::poDS member to the derived type of "
"the owning dataset. If your RasterBand class will need privileged access to "
"the owning dataset object, ensure it is declared as a friend (omitted above "
"for brevity)."
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:366
msgid ""
"If an error occurs, report it with CPLError(), and return CE_Failure. "
"Otherwise return CE_None."
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:367
msgid ""
"The pImage buffer should be filled with one block of data. The block is the "
"size declared in nBlockXSize and nBlockYSize for the raster band. The type "
"of the data within pImage should match the type declared in eDataType in the "
"raster band object."
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:368
msgid ""
"The nBlockXOff and nBlockYOff are block offsets, so with 128x128 tiled "
"datasets values of 1 and 1 would indicate the block going from (128,128) to "
"(255,255) should be loaded."
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:371
msgid "The Driver"
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:373
msgid ""
"While the JDEMDataset and JDEMRasterBand are now ready to use to read image "
"data, it still isn't clear how the GDAL system knows about the new driver. "
"This is accomplished via the :cpp:class:`GDALDriverManager`. To register our "
"format we implement a registration function. The declaration goes in gcore/"
"gdal_frmts.h: void CPL_DLL GDALRegister_JDEM(void);"
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:376
msgid "The definition in the driver file is:"
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:378
msgid ""
"void GDALRegister_JDEM()\n"
"\n"
"{\n"
"    if( !GDAL_CHECK_VERSION(\"JDEM\") )\n"
"        return;\n"
"\n"
"    if( GDALGetDriverByName(\"JDEM\") != nullptr )\n"
"        return;\n"
"\n"
"    GDALDriver *poDriver = new GDALDriver();\n"
"\n"
"    poDriver->SetDescription(\"JDEM\");\n"
"    poDriver->SetMetadataItem(GDAL_DCAP_RASTER, \"YES\");\n"
"    poDriver->SetMetadataItem(GDAL_DMD_LONGNAME, \"Japanese DEM (.mem)\");\n"
"    poDriver->SetMetadataItem(GDAL_DMD_HELPTOPIC, \"drivers/raster/jdem."
"html\");\n"
"    poDriver->SetMetadataItem(GDAL_DMD_EXTENSIONS, \"mem\");\n"
"    poDriver->SetMetadataItem(GDAL_DCAP_VIRTUALIO, \"YES\");\n"
"\n"
"    poDriver->pfnOpen = JDEMDataset::Open;\n"
"    poDriver->pfnIdentify = JDEMDataset::Identify;\n"
"\n"
"    GetGDALDriverManager()->RegisterDriver(poDriver);\n"
"}"
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:405
msgid ""
"Note the use of GDAL_CHECK_VERSION macro. This is a macro that should be "
"used by drivers that can be built as a plugin. As the GDAL C++ ABI may, and "
"will, change between GDAL feature releases (for example from GDAL 3.x.0 to 3."
"y.0), it is necessary to recompile your driver against the header files of "
"the GDAL feature version with which you want to make it work. The "
"GDAL_CHECK_VERSION macro will check that the GDAL version with which the "
"driver was compiled and the version against which it is running are "
"compatible (checking that the major and minor version numbers are equal). "
"The C++ ABI will however remain stable for releases of the same release "
"branch (that is for bug fixes releases x.y.z of a given feature release x."
"y.0)."
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:407
msgid ""
"The registration function will create an instance of a GDALDriver object "
"when first called, and register it with the GDALDriverManager. The following "
"fields can be set in the driver before registering it with the "
"GDALDriverManager."
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:409
msgid ""
"The description is the short name for the format. This is a unique name for "
"this format, often used to identity the driver in scripts and command line "
"programs. Normally 3-5 characters in length, and matching the prefix of the "
"format classes. (mandatory)"
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:410
msgid ""
"GDAL_DCAP_RASTER: set to YES to indicate that this driver handles raster "
"data. (mandatory)"
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:411
msgid ""
"GDAL_DMD_LONGNAME: A longer descriptive name for the file format, but still "
"no longer than 50-60 characters. (mandatory)"
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:412
msgid ""
"GDAL_DMD_HELPTOPIC: The name of a help topic to display for this driver, if "
"any. In this case JDEM format is contained within the various format web "
"page held in gdal/html. (optional)"
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:413
msgid ""
"GDAL_DMD_EXTENSIONS: The extensions used for files of this type, without the "
"leading '.'. If more than one, they should be separated with space. "
"(optional)"
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:414
msgid ""
"GDAL_DMD_MIMETYPE: The standard mime type for this file format, such as "
"\"image/png\". (optional)"
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:415
msgid ""
"GDAL_DMD_CREATIONOPTIONLIST: There is evolving work on mechanisms to "
"describe creation options. See the geotiff driver for an example of this. "
"(optional)"
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:416
msgid ""
"GDAL_DMD_CREATIONDATATYPES: A list of space separated data types supported "
"by this create when creating new datasets. If a Create() method exists, "
"these will be will supported. If a CreateCopy() method exists, this will be "
"a list of types that can be losslessly exported but it may include weaker "
"data types than the type eventually written. For instance, a format with a "
"CreateCopy() method, and that always writes Float32 might also list Byte, "
"Int16, and UInt16 since they can losslessly translated to Float32. An "
"example value might be \"Byte Int16 UInt16\". (required - if creation "
"supported)"
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:417
msgid ""
"GDAL_DCAP_VIRTUALIO: set to YES to indicate that this driver can deal with "
"files opened with the VSI*L GDAL API. Otherwise this metadata item should "
"not be defined. (optional)"
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:418
msgid ""
"pfnOpen: The function to call to try opening files of this format. (optional)"
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:419
msgid ""
"pfnIdentify: The function to call to try identifying files of this format. A "
"driver should return 1 if it recognizes the file as being of its format, 0 "
"if it recognizes the file as being NOT of its format, or -1 if it cannot "
"reach to a firm conclusion by just examining the header bytes. (optional)"
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:420
msgid ""
"pfnCreate: The function to call to create new updatable datasets of this "
"format. (optional)"
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:421
msgid ""
"pfnCreateCopy: The function to call to create a new dataset of this format "
"copied from another source, but not necessary updatable. (optional)"
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:422
msgid ""
"pfnDelete: The function to call to delete a dataset of this format. "
"(optional)"
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:423
msgid ""
"pfnUnloadDriver: A function called only when the driver is destroyed. Could "
"be used to cleanup data at the driver level. Rarely used. (optional)"
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:425
msgid ""
"For a driver that can be built as a plugin (that is to say a standalone "
"shared object, loaded at runtime by GDAL), since GDAL 3.9 and :ref:`rfc-96`, "
"there is a way to implement the driver in a way where the plugin will be "
"loaded only when necessary, and not immediately at :cpp:func:"
"`GDALAllRegister` time. Consult :ref:`rfc96_example_driver` for the changes "
"needed to make the driver compatible of deferred plugin loading."
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:428
msgid "Adding Driver to GDAL Tree"
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:430
msgid ""
"Note that the GDALRegister_JDEM() method must be called by the higher level "
"program in order to have access to the JDEM driver. Normal practice when "
"writing new drivers is to:"
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:432
msgid ""
"Add a driver directory under frmts, with the directory name the same as the "
"short name."
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:433
msgid ""
"Add a CMakeLists.txt in that directory modeled on those from other similar "
"directories (i.e. the jdem directory)."
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:434
msgid ""
"Reference the new driver in frmts/CMakeLists.txt, using the "
"gdal_optional_format() or gdal_dependent_format() functions depending if it "
"requires no external dependency or it has at least one."
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:435
msgid ""
"Add the module with the dataset, and rasterband implementation. Generally "
"this is called <short_name>dataset.cpp, with all the GDAL specific code in "
"one file, though that is not required."
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:436
msgid ""
"Add the registration entry point declaration (i.e. GDALRegister_JDEM()) to "
"gcore/gdal_frmts.h."
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:437
msgid ""
"Add a call to the registration function to frmts/gdalallregister.cpp, "
"protected by an appropriate #ifdef."
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:439
msgid ""
"Once this is all done, it should be possible to rebuild GDAL, and have the "
"new format available in all the utilities. The :ref:`gdalinfo` utility can "
"be used to test that opening and reporting on the format is working, and "
"the :ref:`gdal_translate` utility can be used to test image reading."
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:442
msgid "Adding Georeferencing"
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:444
msgid ""
"Now we will take the example a step forward, adding georeferencing support. "
"We add the following two virtual method overrides to JDEMDataset, taking "
"care to exactly match the signature of the method on the GDALDataset base "
"class."
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:446
msgid ""
"CPLErr GetGeoTransform( double * padfTransform ) override;\n"
"const OGRSpatialReference* GetSpatialRef() const override;"
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:451
msgid ""
"The implementation of :cpp:func:`GDALDataset::GetGeoTransform` just copies "
"the usual geotransform matrix into the supplied buffer. Note that :cpp:func:"
"`GDALDataset::GetGeoTransform` may be called a lot, so it isn't generally "
"wise to do a lot of computation in it. In many cases the Open() will collect "
"the geotransform, and this method will just copy it over. Also note that the "
"geotransform return is based on an anchor point at the top left corner of "
"the top left pixel, not the center of pixel approach used in some packages."
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:453
msgid ""
"CPLErr JDEMDataset::GetGeoTransform( double *padfTransform )\n"
"{\n"
"    const char *psHeader = reinterpret_cast<const char *>(m_abyHeader);\n"
"\n"
"    const double dfLLLat = JDEMGetAngle(psHeader + 29);\n"
"    const double dfLLLong = JDEMGetAngle(psHeader + 36);\n"
"    const double dfURLat = JDEMGetAngle(psHeader + 43);\n"
"    const double dfURLong = JDEMGetAngle(psHeader + 50);\n"
"\n"
"    padfTransform[0] = dfLLLong;\n"
"    padfTransform[3] = dfURLat;\n"
"    padfTransform[1] = (dfURLong - dfLLLong) / GetRasterXSize();\n"
"    padfTransform[2] = 0.0;\n"
"\n"
"    padfTransform[4] = 0.0;\n"
"    padfTransform[5] = -1 * (dfURLat - dfLLLat) / GetRasterYSize();\n"
"\n"
"    return CE_None;\n"
"}"
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:475
msgid ""
"The :cpp:func:`GDALDataset::GetSpatialRef` method returns a pointer to an "
"internal OGRSpatialReference object."
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:477
msgid ""
"const OGRSpatialReference *JDEMDataset::GetSpatialRef() const\n"
"{\n"
"    return &m_oSRS;\n"
"}"
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:484
msgid ""
"In this case the coordinate system is fixed for all files of this format, "
"and has been initialized in the JDEMDataset constructor. But in more complex "
"cases, a definition may need to be composed on the fly, in which case it may "
"be helpful to use the :cpp:class:`OGRSpatialReference` class to help build "
"the definition."
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:489
msgid ""
"JDEMDataset::JDEMDataset()\n"
"{\n"
"    std::fill_n(m_abyHeader, CPL_ARRAYSIZE(m_abyHeader), "
"static_cast<GByte>(0));\n"
"    m_oSRS.SetAxisMappingStrategy(OAMS_TRADITIONAL_GIS_ORDER);\n"
"    m_oSRS.importFromEPSG(4301); // Tokyo geographic CRS\n"
"}"
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:498
msgid ""
"This completes explanation of the features of the JDEM driver. The full "
"source for jdemdataset.cpp can be reviewed as needed."
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:501
msgid "Overviews"
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:503
msgid ""
"GDAL allows file formats to make pre-built overviews available to "
"applications via the :cpp:func:`GDALRasterBand::GetOverview` and related "
"methods. However, implementing this is pretty involved, and goes beyond the "
"scope of this document for now. The GeoTIFF driver (gdal/frmts/gtiff/geotiff."
"cpp) and related source can be reviewed for an example of a file format "
"implementing overview reporting and creation support."
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:505
msgid ""
"Formats can also report that they have arbitrary overviews, by overriding "
"the :cpp:func:`GDALRasterBand::HasArbitraryOverviews` method on the "
"GDALRasterBand, returning TRUE. In this case the raster band object is "
"expected to override the :cpp:func:`GDALRasterBand::RasterIO` method itself, "
"to implement efficient access to imagery with resampling. This is also "
"involved, and there are a lot of requirements for correct implementation of "
"the RasterIO() method. An example of this can be found in the OGDI and ECW "
"formats."
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:507
msgid ""
"However, by far the most common approach to implementing overviews is to use "
"the default support in GDAL for external overviews stored in TIFF files with "
"the same name as the dataset, but the extension .ovr appended. In order to "
"enable reading and creation of this style of overviews it is necessary for "
"the GDALDataset to initialize the `oOvManager` object within itself. This is "
"typically accomplished with a call like the following near the end of the "
"Open() method (after the PAM :cpp:func:`GDALDataset::TryLoadXML`)."
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:509
msgid "poDS->oOvManager.Initialize(poDS.get(), poOpenInfo->pszFilename);"
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:513
msgid ""
"This will enable default implementations for reading and creating overviews "
"for the format. It is advised that this be enabled for all simple file "
"system based formats unless there is a custom overview mechanism to be tied "
"into."
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:516
msgid "File Creation"
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:518
msgid ""
"There are two approaches to file creation. The first method is called the :"
"cpp:func:`GDALDriver::CreateCopy` method, and involves implementing a "
"function that can write a file in the output format, pulling all imagery and "
"other information needed from a source GDALDataset. The second method, the "
"dynamic creation method, involves implementing a Create method to create the "
"shell of the file, and then the application writes various information by "
"calls to set methods."
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:520
msgid ""
"The benefits of the first method are that that all the information is "
"available at the point the output file is being created. This can be "
"especially important when implementing file formats using external libraries "
"which require information like color maps, and georeferencing information at "
"the point the file is created. The other advantage of this method is that "
"the CreateCopy() method can read some kinds of information, such as min/max, "
"scaling, description and GCPs for which there are no equivalent set methods."
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:522
msgid ""
"The benefits of the second method are that applications can create an empty "
"new file, and write results to it as they become available. A complete image "
"of the desired data does not have to be available in advance."
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:524
msgid ""
"For very important formats both methods may be implemented, otherwise do "
"whichever is simpler, or provides the required capabilities."
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:527
msgid "CreateCopy"
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:529
msgid ""
"The GDALDriver::CreateCopy() method call is passed through directly, so that "
"method should be consulted for details of arguments. However, some things to "
"keep in mind are:"
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:531
msgid ""
"If the `bStrict` flag is FALSE the driver should try to do something "
"reasonable when it cannot exactly represent the source dataset, transforming "
"data types on the fly, dropping georeferencing and so forth."
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:532
msgid ""
"Implementing progress reporting correctly is somewhat involved. The return "
"result of the progress function needs always to be checked for cancellation, "
"and progress should be reported at reasonable intervals. The "
"JPEGCreateCopy() method demonstrates good handling of the progress function."
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:533
msgid ""
"Special creation options should be documented in the on-line help. If the "
"options take the format \"NAME=VALUE\" the papszOptions list can be "
"manipulated with :cpp:func:`CPLFetchNameValue` as demonstrated in the "
"handling of the QUALITY and PROGRESSIVE flags for JPEGCreateCopy()."
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:534
msgid ""
"The returned GDALDataset handle can be in ReadOnly or Update mode. Return it "
"in Update mode if practical, otherwise in ReadOnly mode is fine."
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:536
msgid ""
"The full implementation of the CreateCopy function for JPEG (which is "
"assigned to pfnCreateCopy in the GDALDriver object) is here. static "
"GDALDataset *"
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:539
msgid ""
"JPEGCreateCopy( const char * pszFilename, GDALDataset *poSrcDS,\n"
"                int bStrict, char ** papszOptions,\n"
"                GDALProgressFunc pfnProgress, void * pProgressData )\n"
"{\n"
"    const int nBands = poSrcDS->GetRasterCount();\n"
"    const int nXSize = poSrcDS->GetRasterXSize();\n"
"    const int nYSize = poSrcDS->GetRasterYSize();\n"
"    // Some some rudimentary checks\n"
"    if( nBands != 1 && nBands != 3 )\n"
"    {\n"
"        CPLError(CE_Failure, CPLE_NotSupported,\n"
"                \"JPEG driver doesn't support %d bands.  Must be 1 (grey) "
"\"\n"
"                \"or 3 (RGB) bands.\", nBands);\n"
"        return NULL;\n"
"    }\n"
"\n"
"    if( poSrcDS->GetRasterBand(1)->GetRasterDataType() != GDT_Byte && "
"bStrict )\n"
"    {\n"
"        CPLError(CE_Failure, CPLE_NotSupported,\n"
"                \"JPEG driver doesn't support data type %s. \"\n"
"                \"Only eight bit byte bands supported.\",\n"
"                GDALGetDataTypeName(\n"
"                    poSrcDS->GetRasterBand(1)->GetRasterDataType()));\n"
"        return NULL;\n"
"    }\n"
"\n"
"    // What options has the user selected?\n"
"    int nQuality = 75;\n"
"    if( CSLFetchNameValue(papszOptions, \"QUALITY\") != NULL )\n"
"    {\n"
"        nQuality = atoi(CSLFetchNameValue(papszOptions, \"QUALITY\"));\n"
"        if( nQuality < 10 || nQuality > 100 )\n"
"        {\n"
"            CPLError(CE_Failure, CPLE_IllegalArg,\n"
"                    \"QUALITY=%s is not a legal value in the range 10 - 100."
"\",\n"
"                    CSLFetchNameValue(papszOptions, \"QUALITY\"));\n"
"            return NULL;\n"
"        }\n"
"    }\n"
"\n"
"    bool bProgressive = false;\n"
"    if( CSLFetchNameValue(papszOptions, \"PROGRESSIVE\") != NULL )\n"
"    {\n"
"        bProgressive = true;\n"
"    }\n"
"\n"
"    // Create the dataset.\n"
"    VSILFILE *fpImage = VSIFOpenL(pszFilename, \"wb\");\n"
"    if( fpImage == NULL )\n"
"    {\n"
"        CPLError(CE_Failure, CPLE_OpenFailed,\n"
"                \"Unable to create jpeg file %s.\",\n"
"                pszFilename);\n"
"        return NULL;\n"
"    }\n"
"\n"
"    // Initialize JPG access to the file.\n"
"    struct jpeg_compress_struct sCInfo;\n"
"    struct jpeg_error_mgr sJErr;\n"
"    sCInfo.err = jpeg_std_error(&sJErr);\n"
"    jpeg_create_compress(&sCInfo);\n"
"    jpeg_stdio_dest(&sCInfo, fpImage);\n"
"    sCInfo.image_width = nXSize;\n"
"    sCInfo.image_height = nYSize;\n"
"    sCInfo.input_components = nBands;\n"
"    if( nBands == 1 )\n"
"    {\n"
"        sCInfo.in_color_space = JCS_GRAYSCALE;\n"
"    }\n"
"    else\n"
"    {\n"
"        sCInfo.in_color_space = JCS_RGB;\n"
"    }\n"
"    jpeg_set_defaults(&sCInfo);\n"
"    jpeg_set_quality(&sCInfo, nQuality, TRUE);\n"
"    if( bProgressive )\n"
"        jpeg_simple_progression(&sCInfo);\n"
"    jpeg_start_compress(&sCInfo, TRUE);\n"
"\n"
"    // Loop over image, copying image data.\n"
"    GByte *pabyScanline = static_cast<GByte *>(CPLMalloc(nBands * nXSize));\n"
"    for( int iLine = 0; iLine < nYSize; iLine++ )\n"
"    {\n"
"        for( int iBand = 0; iBand < nBands; iBand++ )\n"
"        {\n"
"            GDALRasterBand * poBand = poSrcDS->GetRasterBand(iBand + 1);\n"
"            const CPLErr eErr =\n"
"                poBand->RasterIO(GF_Read, 0, iLine, nXSize, 1,\n"
"                                pabyScanline + iBand, nXSize, 1, GDT_Byte,\n"
"                                nBands, nBands * nXSize);\n"
"            // TODO: Handle error.\n"
"        }\n"
"        JSAMPLE *ppSamples = pabyScanline;\n"
"        jpeg_write_scanlines(&sCInfo, &ppSamples, 1);\n"
"    }\n"
"    CPLFree(pabyScanline);\n"
"    jpeg_finish_compress(&sCInfo);\n"
"    jpeg_destroy_compress(&sCInfo);\n"
"    VSIFCloseL(fpImage);\n"
"    return static_cast<GDALDataset *>(GDALOpen(pszFilename, GA_ReadOnly));\n"
"}"
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:644
msgid "Dynamic Creation"
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:646
msgid ""
"In the case of dynamic creation, there is no source dataset. Instead the "
"size, number of bands, and pixel data type of the desired file is provided "
"but other information (such as georeferencing, and imagery data) would be "
"supplied later via other method calls on the resulting GDALDataset."
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:648
msgid ""
"The following sample implement PCI .aux labeled raw raster creation. It "
"follows a common approach of creating a blank, but valid file using non-GDAL "
"calls, and then calling GDALOpen(,GA_Update) at the end to return a writable "
"file handle. This avoids having to duplicate the various setup actions in "
"the Open() function."
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:650
msgid ""
"GDALDataset *PAuxDataset::Create( const char * pszFilename,\n"
"                                int nXSize, int nYSize, int nBands,\n"
"                                GDALDataType eType,\n"
"                                char ** /* papszParamList */ )\n"
"{\n"
"    // Verify input options.\n"
"    if( eType != GDT_Byte && eType != GDT_Float32 &&\n"
"        eType != GDT_UInt16 && eType != GDT_Int16 )\n"
"    {\n"
"        CPLError(\n"
"            CE_Failure, CPLE_AppDefined,\n"
"            \"Attempt to create PCI .Aux labeled dataset with an illegal \"\n"
"            \"data type (%s).\",\n"
"            GDALGetDataTypeName(eType));\n"
"        return NULL;\n"
"    }\n"
"\n"
"    // Try to create the file.\n"
"    FILE *fp = VSIFOpen(pszFilename, \"w\");\n"
"    if( fp == NULL )\n"
"    {\n"
"        CPLError(CE_Failure, CPLE_OpenFailed,\n"
"                \"Attempt to create file `%s' failed.\",\n"
"                pszFilename);\n"
"        return NULL;\n"
"    }\n"
"\n"
"    // Just write out a couple of bytes to establish the binary\n"
"    // file, and then close it.\n"
"    VSIFWrite(\"\\0\\0\", 2, 1, fp);\n"
"    VSIFClose(fp);\n"
"\n"
"    // Create the aux filename.\n"
"    char *pszAuxFilename = static_cast<char *>(CPLMalloc(strlen(pszFilename) "
"+ 5));\n"
"    strcpy(pszAuxFilename, pszFilename);;\n"
"    for( int i = strlen(pszAuxFilename) - 1; i > 0; i-- )\n"
"    {\n"
"        if( pszAuxFilename[i] == '.' )\n"
"        {\n"
"            pszAuxFilename[i] = '\\0';\n"
"            break;\n"
"        }\n"
"    }\n"
"    strcat(pszAuxFilename, \".aux\");\n"
"\n"
"    // Open the file.\n"
"    fp = VSIFOpen(pszAuxFilename, \"wt\");\n"
"    if( fp == NULL )\n"
"    {\n"
"        CPLError(CE_Failure, CPLE_OpenFailed,\n"
"                \"Attempt to create file `%s' failed.\",\n"
"                pszAuxFilename);\n"
"        return NULL;\n"
"    }\n"
"\n"
"    // We need to write out the original filename but without any\n"
"    // path components in the AuxiliaryTarget line.  Do so now.\n"
"    int iStart = strlen(pszFilename) - 1;\n"
"    while( iStart > 0 && pszFilename[iStart - 1] != '/' &&\n"
"        pszFilename[iStart - 1] != '\\\\' )\n"
"        iStart--;\n"
"    VSIFPrintf(fp, \"AuxilaryTarget: %s\\n\", pszFilename + iStart);\n"
"\n"
"    // Write out the raw definition for the dataset as a whole.\n"
"    VSIFPrintf(fp, \"RawDefinition: %d %d %d\\n\",\n"
"            nXSize, nYSize, nBands);\n"
"\n"
"    // Write out a definition for each band.  We always write band\n"
"    // sequential files for now as these are pretty efficiently\n"
"    // handled by GDAL.\n"
"    int nImgOffset = 0;\n"
"    for( int iBand = 0; iBand < nBands; iBand++ )\n"
"    {\n"
"        const int nPixelOffset = GDALGetDataTypeSize(eType)/8;\n"
"        const int nLineOffset = nXSize * nPixelOffset;\n"
"        const char *pszTypeName = NULL;\n"
"        if( eType == GDT_Float32 )\n"
"            pszTypeName = \"32R\";\n"
"        else if( eType == GDT_Int16 )\n"
"            pszTypeName = \"16S\";\n"
"        else if( eType == GDT_UInt16 )\n"
"            pszTypeName = \"16U\";\n"
"        else\n"
"            pszTypeName = \"8U\";\n"
"        VSIFPrintf( fp, \"ChanDefinition-%d: %s %d %d %d %s\\n\",\n"
"                    iBand + 1, pszTypeName,\n"
"                    nImgOffset, nPixelOffset, nLineOffset,\n"
"#ifdef CPL_LSB\n"
"                    \"Swapped\"\n"
"#else\n"
"                    \"Unswapped\"\n"
"#endif\n"
"                    );\n"
"        nImgOffset += nYSize * nLineOffset;\n"
"    }\n"
"\n"
"    // Cleanup.\n"
"    VSIFClose(fp);\n"
"    return static_cast<GDALDataset *>(GDALOpen(pszFilename, GA_Update));\n"
"}"
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:753
msgid ""
"File formats supporting dynamic creation, or even just update-in-place "
"access also need to implement an IWriteBlock() method on the raster band "
"class. It has semantics similar to IReadBlock(). As well, for various "
"esoteric reasons, it is critical that a FlushCache() method be implemented "
"in the raster band destructor. This is to ensure that any write cache blocks "
"for the band be flushed out before the destructor is called."
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:756
msgid "RawDataset/RawRasterBand Helper Classes"
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:758
msgid ""
"Many file formats have the actual imagery data stored in a regular, binary, "
"scanline oriented format. Rather than re-implement the access semantics for "
"this for each formats, there are provided :cpp:class:`RawDataset` and :cpp:"
"class:`RawRasterBand` classes declared in gcore/ that can be utilized to "
"implement efficient and convenient access."
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:760
msgid ""
"In these cases the format specific band class may not be required, or if "
"required it can be derived from RawRasterBand. The dataset class should be "
"derived from RawDataset."
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:762
msgid ""
"The Open() method for the dataset then instantiates raster bands passing all "
"the layout information to the constructor. For instance, the PNM driver uses "
"the following calls to create it's raster bands."
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:764
msgid ""
"if( poOpenInfo->pabyHeader[1] == '5' )\n"
"{\n"
"    poDS->SetBand(\n"
"        1, new RawRasterBand(poDS, 1, poDS->fpImage,\n"
"                            iIn, 1, nWidth, GDT_Byte, TRUE));\n"
"}\n"
"else\n"
"{\n"
"    poDS->SetBand(\n"
"        1, new RawRasterBand(poDS, 1, poDS->fpImage,\n"
"                            iIn, 3, nWidth*3, GDT_Byte, TRUE));\n"
"    poDS->SetBand(\n"
"        2, new RawRasterBand(poDS, 2, poDS->fpImage,\n"
"                            iIn+1, 3, nWidth*3, GDT_Byte, TRUE));\n"
"    poDS->SetBand(\n"
"        3, new RawRasterBand(poDS, 3, poDS->fpImage,\n"
"                            iIn+2, 3, nWidth*3, GDT_Byte, TRUE));\n"
"}"
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:785
msgid "The RawRasterBand takes the following arguments."
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:787
msgid ""
"poDS: The GDALDataset this band will be a child of. This dataset must be of "
"a class derived from RawRasterDataset."
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:788
msgid "nBand: The band it is on that dataset, 1 based."
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:789
msgid "fpRaw: The FILE * handle to the file containing the raster data."
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:790
msgid ""
"nImgOffset: The byte offset to the first pixel of raster data for the first "
"scanline."
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:791
msgid ""
"nPixelOffset: The byte offset from the start of one pixel to the start of "
"the next within the scanline."
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:792
msgid ""
"nLineOffset: The byte offset from the start of one scanline to the start of "
"the next."
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:793
msgid "eDataType: The GDALDataType code for the type of the data on disk."
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:794
msgid ""
"bNativeOrder: FALSE if the data is not in the same endianness as the machine "
"GDAL is running on. The data will be automatically byte swapped."
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:796
msgid ""
"Simple file formats utilizing the Raw services are normally placed all "
"within one file in the gdal/frmts/raw directory. There are numerous examples "
"there of format implementation."
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:799
msgid "Metadata, and Other Exotic Extensions"
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:801
msgid ""
"There are various other items in the GDAL data model, for which virtual "
"methods exist on the GDALDataset and GDALRasterBand. They include:"
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:803
msgid ""
"Metadata: Name/value text values about a dataset or band. The "
"GDALMajorObject (base class for GDALRasterBand and GDALDataset) has built-in "
"support for holding metadata, so for read access it only needs to be set "
"with calls to SetMetadataItem() during the Open(). The SAR_CEOS (frmts/ceos2/"
"sar_ceosdataset.cpp) and GeoTIFF drivers are examples of drivers "
"implementing readable metadata."
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:805
msgid ""
"ColorTables: GDT_Byte raster bands can have color tables associated with "
"them. The frmts/png/pngdataset.cpp driver contains an example of a format "
"that supports colortables."
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:807
msgid ""
"ColorInterpretation: The PNG driver contains an example of a driver that "
"returns an indication of whether a band should be treated as a Red, Green, "
"Blue, Alpha or Greyscale band."
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:809
msgid ""
"GCPs: GDALDatasets can have a set of ground control points associated with "
"them (as opposed to an explicit affine transform returned by "
"GetGeotransform()) relating the raster to georeferenced coordinates. The "
"MFF2 (gdal/frmts/raw/hkvdataset.cpp) format is a simple example of a format "
"supporting GCPs."
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:811
msgid ""
"NoDataValue: Bands with known \"nodata\" values can implement the "
"GetNoDataValue() method. See the PAux (frmts/raw/pauxdataset.cpp) for an "
"example of this."
msgstr ""

#: ../../../source/tutorials/raster_driver_tut.rst:813
msgid ""
"Category Names: Classified images with names for each class can return them "
"using the GetCategoryNames() method though no formats currently implement "
"this."
msgstr ""
