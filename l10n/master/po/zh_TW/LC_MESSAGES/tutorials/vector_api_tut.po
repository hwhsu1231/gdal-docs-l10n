# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1998-2024
# This file is distributed under the same license as the GDAL package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: GDAL master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-04-22 19:28+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../source/tutorials/vector_api_tut.rst:5
msgid "Vector API tutorial"
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:7
msgid ""
"This document is intended to document using the OGR C++ classes to read and "
"write data from a file.  It is strongly advised that the reader first review "
"the :ref:`vector_data_model` document describing the key classes and their "
"roles in OGR."
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:12
msgid ""
"It also includes code snippets for the corresponding functions in C and "
"Python."
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:15
msgid "Reading From OGR"
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:17
msgid ""
"For purposes of demonstrating reading with OGR, we will construct a small "
"utility for dumping point layers from an OGR data source to stdout in comma-"
"delimited format."
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:21
msgid ""
"Initially it is necessary to register all the format drivers that are "
"desired. This is normally accomplished by calling :cpp:func:"
"`GDALAllRegister` which registers all format drivers built into GDAL/OGR."
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:25
#: ../../../source/tutorials/vector_api_tut.rst:57
#: ../../../source/tutorials/vector_api_tut.rst:88
#: ../../../source/tutorials/vector_api_tut.rst:287
#: ../../../source/tutorials/vector_api_tut.rst:335
#: ../../../source/tutorials/vector_api_tut.rst:431
#: ../../../source/tutorials/vector_api_tut.rst:537
#: ../../../source/tutorials/vector_api_tut.rst:1040
#: ../../../source/tutorials/vector_api_tut.rst:1121
#: ../../../source/tutorials/vector_api_tut.rst:1213
#: ../../../source/tutorials/vector_api_tut.rst:1237
#: ../../../source/tutorials/vector_api_tut.rst:1263
#: ../../../source/tutorials/vector_api_tut.rst:1303
#: ../../../source/tutorials/vector_api_tut.rst:1528
#: ../../../source/tutorials/vector_api_tut.rst:1598
msgid "In C++ :"
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:27
msgid ""
"#include \"ogrsf_frmts.h\"\n"
"\n"
"int main()\n"
"\n"
"{\n"
"    GDALAllRegister();"
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:37
#: ../../../source/tutorials/vector_api_tut.rst:70
#: ../../../source/tutorials/vector_api_tut.rst:96
#: ../../../source/tutorials/vector_api_tut.rst:234
#: ../../../source/tutorials/vector_api_tut.rst:310
#: ../../../source/tutorials/vector_api_tut.rst:365
#: ../../../source/tutorials/vector_api_tut.rst:438
#: ../../../source/tutorials/vector_api_tut.rst:615
#: ../../../source/tutorials/vector_api_tut.rst:1060
#: ../../../source/tutorials/vector_api_tut.rst:1103
#: ../../../source/tutorials/vector_api_tut.rst:1135
#: ../../../source/tutorials/vector_api_tut.rst:1222
#: ../../../source/tutorials/vector_api_tut.rst:1248
#: ../../../source/tutorials/vector_api_tut.rst:1276
#: ../../../source/tutorials/vector_api_tut.rst:1382
#: ../../../source/tutorials/vector_api_tut.rst:1557
#: ../../../source/tutorials/vector_api_tut.rst:1624
msgid "In C :"
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:39
msgid ""
"#include \"gdal.h\"\n"
"\n"
"int main()\n"
"\n"
"{\n"
"    GDALAllRegister();"
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:48
msgid ""
"Next we need to open the input OGR datasource.  Datasources can be files, "
"RDBMSes, directories full of files, or even remote web services depending on "
"the driver being used.  However, the datasource name is always a single "
"string.  In this case we are hardcoded to open a particular shapefile. The "
"second argument (GDAL_OF_VECTOR) tells the :cpp:func:`OGROpen` method that "
"we want a vector driver to be use and that don't require update access. On "
"failure NULL is returned, and we report an error."
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:59
msgid ""
"GDALDataset       *poDS;\n"
"\n"
"poDS = (GDALDataset*) GDALOpenEx( \"point.shp\", GDAL_OF_VECTOR, NULL, NULL, "
"NULL );\n"
"if( poDS == NULL )\n"
"{\n"
"    printf( \"Open failed.\\n\" );\n"
"    exit( 1 );\n"
"}"
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:72
msgid ""
"GDALDatasetH hDS;\n"
"\n"
"hDS = GDALOpenEx( \"point.shp\", GDAL_OF_VECTOR, NULL, NULL, NULL );\n"
"if( hDS == NULL )\n"
"{\n"
"    printf( \"Open failed.\\n\" );\n"
"    exit( 1 );\n"
"}"
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:83
msgid ""
"A GDALDataset can potentially have many layers associated with it.  The "
"number of layers available can be queried with :cpp:func:`GDALDataset::"
"GetLayerCount` and individual layers fetched by index using :cpp:func:"
"`GDALDataset::GetLayer`. However, we will just fetch the layer by name."
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:90
msgid ""
"OGRLayer  *poLayer;\n"
"\n"
"poLayer = poDS->GetLayerByName( \"point\" );"
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:98
msgid ""
"OGRLayerH hLayer;\n"
"\n"
"hLayer = GDALDatasetGetLayerByName( hDS, \"point\" );"
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:105
msgid ""
"Now we want to start reading features from the layer.  Before we start we "
"could assign an attribute or spatial filter to the layer to restrict the set "
"of feature we get back, but for now we are interested in getting all "
"features."
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:109
#: ../../../source/tutorials/vector_api_tut.rst:155
msgid "With GDAL 2.3 and C++11:"
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:111
msgid ""
"for( auto& poFeature: poLayer )\n"
"{"
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:116
msgid "With GDAL 2.3 and C:"
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:118
msgid ""
"OGR_FOR_EACH_FEATURE_BEGIN(hFeature, hLayer)\n"
"{"
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:123
msgid ""
"If using older GDAL versions, while it isn't strictly necessary in this "
"circumstance since we are starting fresh with the layer, it is often wise to "
"call :cpp:func:`OGRLayer::ResetReading` to ensure we are starting at the "
"beginning of the layer.  We iterate through all the features in the layer "
"using OGRLayer::GetNextFeature().  It will return NULL when we run out of "
"features."
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:129
#: ../../../source/tutorials/vector_api_tut.rst:195
msgid "With GDAL < 2.3 and C++ :"
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:131
msgid ""
"OGRFeature *poFeature;\n"
"\n"
"poLayer->ResetReading();\n"
"while( (poFeature = poLayer->GetNextFeature()) != NULL )\n"
"{"
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:140
msgid "With GDAL < 2.3 and C :"
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:142
msgid ""
"OGRFeatureH hFeature;\n"
"\n"
"OGR_L_ResetReading(hLayer);\n"
"while( (hFeature = OGR_L_GetNextFeature(hLayer)) != NULL )\n"
"{"
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:150
msgid ""
"In order to dump all the attribute fields of the feature, it is helpful to "
"get the :cpp:class:`OGRFeatureDefn`.  This is an object, associated with the "
"layer, containing the definitions of all the fields.  We loop over all the "
"fields, and fetch and report the attributes based on their type."
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:157
msgid ""
"for( auto&& oField: *poFeature )\n"
"{\n"
"    if( oField.IsUnset() )\n"
"    {\n"
"        printf(\"(unset),\");\n"
"        continue;\n"
"    }\n"
"    if( oField.IsNull() )\n"
"    {\n"
"        printf(\"(null),\");\n"
"        continue;\n"
"    }\n"
"    switch( oField.GetType() )\n"
"    {\n"
"        case OFTInteger:\n"
"            printf( \"%d,\", oField.GetInteger() );\n"
"            break;\n"
"        case OFTInteger64:\n"
"            printf( CPL_FRMT_GIB \",\", oField.GetInteger64() );\n"
"            break;\n"
"        case OFTReal:\n"
"            printf( \"%.3f,\", oField.GetDouble() );\n"
"            break;\n"
"        case OFTString:\n"
"            // GetString() returns a C string\n"
"            printf( \"%s,\", oField.GetString() );\n"
"            break;\n"
"        default:\n"
"            // Note: we use GetAsString() and not GetString(), since\n"
"            // the later assumes the field type to be OFTString while the\n"
"            // former will do a conversion from the original type to "
"string.\n"
"            printf( \"%s,\", oField.GetAsString() );\n"
"            break;\n"
"    }\n"
"}"
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:197
msgid ""
"OGRFeatureDefn *poFDefn = poLayer->GetLayerDefn();\n"
"for( int iField = 0; iField < poFDefn->GetFieldCount(); iField++ )\n"
"{\n"
"    if( !poFeature->IsFieldSet(iField) )\n"
"    {\n"
"        printf(\"(unset),\");\n"
"        continue;\n"
"    }\n"
"    if( poFeature->IsFieldNull(iField) )\n"
"    {\n"
"        printf(\"(null),\");\n"
"        continue;\n"
"    }\n"
"    OGRFieldDefn *poFieldDefn = poFDefn->GetFieldDefn( iField );\n"
"\n"
"    switch( poFieldDefn->GetType() )\n"
"    {\n"
"        case OFTInteger:\n"
"            printf( \"%d,\", poFeature->GetFieldAsInteger( iField ) );\n"
"            break;\n"
"        case OFTInteger64:\n"
"            printf( CPL_FRMT_GIB \",\", poFeature-"
">GetFieldAsInteger64( iField ) );\n"
"            break;\n"
"        case OFTReal:\n"
"            printf( \"%.3f,\", poFeature->GetFieldAsDouble(iField) );\n"
"            break;\n"
"        case OFTString:\n"
"            printf( \"%s,\", poFeature->GetFieldAsString(iField) );\n"
"            break;\n"
"        default:\n"
"            printf( \"%s,\", poFeature->GetFieldAsString(iField) );\n"
"            break;\n"
"    }\n"
"}"
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:236
msgid ""
"OGRFeatureDefnH hFDefn = OGR_L_GetLayerDefn(hLayer);\n"
"int iField;\n"
"\n"
"for( iField = 0; iField < OGR_FD_GetFieldCount(hFDefn); iField++ )\n"
"{\n"
"    OGRFieldDefnH hFieldDefn = OGR_FD_GetFieldDefn( hFDefn, iField );\n"
"\n"
"    if( !OGR_F_IsFieldSet(hFeature, iField) )\n"
"    {\n"
"        printf(\"(unset),\");\n"
"        continue;\n"
"    }\n"
"    if( OGR_F_IsFieldNull(hFeature, iField) )\n"
"    {\n"
"        printf(\"(null),\");\n"
"        continue;\n"
"    }\n"
"\n"
"    switch( OGR_Fld_GetType(hFieldDefn) )\n"
"    {\n"
"        case OFTInteger:\n"
"            printf( \"%d,\", OGR_F_GetFieldAsInteger( hFeature, iField ) );\n"
"            break;\n"
"        case OFTInteger64:\n"
"            printf( CPL_FRMT_GIB \",\", OGR_F_GetFieldAsInteger64( hFeature, "
"iField ) );\n"
"            break;\n"
"        case OFTReal:\n"
"            printf( \"%.3f,\", OGR_F_GetFieldAsDouble( hFeature, iField) );\n"
"            break;\n"
"        case OFTString:\n"
"            printf( \"%s,\", OGR_F_GetFieldAsString( hFeature, iField) );\n"
"            break;\n"
"        default:\n"
"            printf( \"%s,\", OGR_F_GetFieldAsString( hFeature, iField) );\n"
"            break;\n"
"    }\n"
"}"
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:276
msgid ""
"There are a few more field types than those explicitly handled above, but a "
"reasonable representation of them can be fetched with the :cpp:func:"
"`OGRFeature::GetFieldAsString` method.  In fact we could shorten the above "
"by using GetFieldAsString() for all the types."
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:281
msgid ""
"Next we want to extract the geometry from the feature, and write out the "
"point geometry x and y.   Geometries are returned as a generic :cpp:class:"
"`OGRGeometry` pointer. We then determine the specific geometry type, and if "
"it is a point, we cast it to point and operate on it.  If it is something "
"else we write placeholders."
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:289
msgid ""
"OGRGeometry *poGeometry;\n"
"\n"
"poGeometry = poFeature->GetGeometryRef();\n"
"if( poGeometry != NULL\n"
"        && wkbFlatten(poGeometry->getGeometryType()) == wkbPoint )\n"
"{\n"
"#if GDAL_VERSION_NUM >= GDAL_COMPUTE_VERSION(2,3,0)\n"
"    OGRPoint *poPoint = poGeometry->toPoint();\n"
"#else\n"
"    OGRPoint *poPoint = (OGRPoint *) poGeometry;\n"
"#endif\n"
"\n"
"    printf( \"%.3f,%3.f\\n\", poPoint->getX(), poPoint->getY() );\n"
"}\n"
"else\n"
"{\n"
"    printf( \"no point geometry\\n\" );\n"
"}"
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:312
msgid ""
"OGRGeometryH hGeometry;\n"
"\n"
"hGeometry = OGR_F_GetGeometryRef(hFeature);\n"
"if( hGeometry != NULL\n"
"        && wkbFlatten(OGR_G_GetGeometryType(hGeometry)) == wkbPoint )\n"
"{\n"
"    printf( \"%.3f,%3.f\\n\", OGR_G_GetX(hGeometry, 0), "
"OGR_G_GetY(hGeometry, 0) );\n"
"}\n"
"else\n"
"{\n"
"    printf( \"no point geometry\\n\" );\n"
"}"
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:327
msgid ""
"The :cpp:func:`wkbFlatten` macro is used above to convert the type for a "
"wkbPoint25D (a point with a z coordinate) into the base 2D geometry type "
"code (wkbPoint). For each 2D geometry type there is a corresponding 2.5D "
"type code.  The 2D and 2.5D geometry cases are handled by the same C++ "
"class, so our code will handle 2D or 3D cases properly."
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:333
msgid "Several geometry fields can be associated to a feature."
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:337
msgid ""
"OGRGeometry *poGeometry;\n"
"int iGeomField;\n"
"int nGeomFieldCount;\n"
"\n"
"nGeomFieldCount = poFeature->GetGeomFieldCount();\n"
"for(iGeomField = 0; iGeomField < nGeomFieldCount; iGeomField ++ )\n"
"{\n"
"    poGeometry = poFeature->GetGeomFieldRef(iGeomField);\n"
"    if( poGeometry != NULL\n"
"            && wkbFlatten(poGeometry->getGeometryType()) == wkbPoint )\n"
"    {\n"
"#if GDAL_VERSION_NUM >= GDAL_COMPUTE_VERSION(2,3,0)\n"
"        OGRPoint *poPoint = poGeometry->toPoint();\n"
"#else\n"
"        OGRPoint *poPoint = (OGRPoint *) poGeometry;\n"
"#endif\n"
"\n"
"        printf( \"%.3f,%3.f\\n\", poPoint->getX(), poPoint->getY() );\n"
"    }\n"
"    else\n"
"    {\n"
"        printf( \"no point geometry\\n\" );\n"
"    }\n"
"}"
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:367
msgid ""
"OGRGeometryH hGeometry;\n"
"int iGeomField;\n"
"int nGeomFieldCount;\n"
"\n"
"nGeomFieldCount = OGR_F_GetGeomFieldCount(hFeature);\n"
"for(iGeomField = 0; iGeomField < nGeomFieldCount; iGeomField ++ )\n"
"{\n"
"    hGeometry = OGR_F_GetGeomFieldRef(hFeature, iGeomField);\n"
"    if( hGeometry != NULL\n"
"            && wkbFlatten(OGR_G_GetGeometryType(hGeometry)) == wkbPoint )\n"
"    {\n"
"        printf( \"%.3f,%3.f\\n\", OGR_G_GetX(hGeometry, 0),\n"
"                OGR_G_GetY(hGeometry, 0) );\n"
"    }\n"
"    else\n"
"    {\n"
"        printf( \"no point geometry\\n\" );\n"
"    }\n"
"}"
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:390
#: ../../../source/tutorials/vector_api_tut.rst:700
msgid "In Python:"
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:392
msgid ""
"nGeomFieldCount = feat.GetGeomFieldCount()\n"
"for iGeomField in range(nGeomFieldCount):\n"
"    geom = feat.GetGeomFieldRef(iGeomField)\n"
"    if geom is not None and geom.GetGeometryType() == ogr.wkbPoint:\n"
"        print \"%.3f, %.3f\" % ( geom.GetX(), geom.GetY() )\n"
"    else:\n"
"        print \"no point geometry\\n\""
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:402
msgid ""
"Note that :cpp:func:`OGRFeature::GetGeometryRef` and :cpp:func:`OGRFeature::"
"GetGeomFieldRef` return a pointer to the internal geometry owned by the "
"OGRFeature.  There we don't actually delete the return geometry."
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:408
msgid ""
"With GDAL 2.3 and C++11, the looping over features is simply terminated by a "
"closing curly bracket."
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:411
msgid "}"
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:415
msgid ""
"With GDAL 2.3 and C, the looping over features is simply terminated by the "
"following."
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:418
msgid ""
"}\n"
"OGR_FOR_EACH_FEATURE_END(hFeature)"
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:424
msgid ""
"For GDAL < 2.3, as the :cpp:func:`OGRLayer::GetNextFeature` method returns a "
"copy of the feature that is now owned by us.  So at the end of use we must "
"free the feature.  We could just \"delete\" it, but this can cause problems "
"in windows builds where the GDAL DLL has a different \"heap\" from the main "
"program.  To be on the safe side we use a GDAL function to delete the "
"feature."
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:433
msgid ""
"    OGRFeature::DestroyFeature( poFeature );\n"
"}"
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:440
msgid ""
"    OGR_F_Destroy( hFeature );\n"
"}"
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:446
msgid ""
"The OGRLayer returned by :cpp:func:`GDALDataset::GetLayerByName` is also a "
"reference to an internal layer owned by the GDALDataset so we don't need to "
"delete it.  But we do need to delete the datasource in order to close the "
"input file. Once again we do this with a custom delete method to avoid "
"special win32 heap issues."
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:452
#: ../../../source/tutorials/vector_api_tut.rst:1293
msgid "In C/C++ :"
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:454
#: ../../../source/tutorials/vector_api_tut.rst:1295
msgid ""
"    GDALClose( poDS );\n"
"}"
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:460
msgid "All together our program looks like this."
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:462
msgid "With GDAL 2.3 and C++11 :"
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:464
msgid ""
"#include \"ogrsf_frmts.h\"\n"
"\n"
"int main()\n"
"\n"
"{\n"
"    GDALAllRegister();\n"
"\n"
"    GDALDatasetUniquePtr poDS(GDALDataset::Open( \"point.shp\", "
"GDAL_OF_VECTOR));\n"
"    if( poDS == nullptr )\n"
"    {\n"
"        printf( \"Open failed.\\n\" );\n"
"        exit( 1 );\n"
"    }\n"
"\n"
"    for( const OGRLayer* poLayer: poDS->GetLayers() )\n"
"    {\n"
"        for( const auto& poFeature: *poLayer )\n"
"        {\n"
"            for( const auto& oField: *poFeature )\n"
"            {\n"
"                if( oField.IsUnset() )\n"
"                {\n"
"                    printf(\"(unset),\");\n"
"                    continue;\n"
"                }\n"
"                if( oField.IsNull() )\n"
"                {\n"
"                    printf(\"(null),\");\n"
"                    continue;\n"
"                }\n"
"                switch( oField.GetType() )\n"
"                {\n"
"                    case OFTInteger:\n"
"                        printf( \"%d,\", oField.GetInteger() );\n"
"                        break;\n"
"                    case OFTInteger64:\n"
"                        printf( CPL_FRMT_GIB \",\", oField."
"GetInteger64() );\n"
"                        break;\n"
"                    case OFTReal:\n"
"                        printf( \"%.3f,\", oField.GetDouble() );\n"
"                        break;\n"
"                    case OFTString:\n"
"                        // GetString() returns a C string\n"
"                        printf( \"%s,\", oField.GetString() );\n"
"                        break;\n"
"                    default:\n"
"                        // Note: we use GetAsString() and not GetString(), "
"since\n"
"                        // the later assumes the field type to be OFTString "
"while the\n"
"                        // former will do a conversion from the original "
"type to string.\n"
"                        printf( \"%s,\", oField.GetAsString() );\n"
"                        break;\n"
"                }\n"
"            }\n"
"\n"
"            const OGRGeometry *poGeometry = poFeature->GetGeometryRef();\n"
"            if( poGeometry != nullptr\n"
"                    && wkbFlatten(poGeometry->getGeometryType()) == "
"wkbPoint )\n"
"            {\n"
"                const OGRPoint *poPoint = poGeometry->toPoint();\n"
"\n"
"                printf( \"%.3f,%3.f\\n\", poPoint->getX(), poPoint-"
">getY() );\n"
"            }\n"
"            else\n"
"            {\n"
"                printf( \"no point geometry\\n\" );\n"
"            }\n"
"        }\n"
"    }\n"
"    return 0;\n"
"}"
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:539
msgid ""
"#include \"ogrsf_frmts.h\"\n"
"\n"
"int main()\n"
"\n"
"{\n"
"    GDALAllRegister();\n"
"\n"
"    GDALDataset *poDS = static_cast<GDALDataset*>(\n"
"        GDALOpenEx( \"point.shp\", GDAL_OF_VECTOR, NULL, NULL, NULL ));\n"
"    if( poDS == NULL )\n"
"    {\n"
"        printf( \"Open failed.\\n\" );\n"
"        exit( 1 );\n"
"    }\n"
"\n"
"    OGRLayer  *poLayer = poDS->GetLayerByName( \"point\" );\n"
"    OGRFeatureDefn *poFDefn = poLayer->GetLayerDefn();\n"
"\n"
"    poLayer->ResetReading();\n"
"    OGRFeature *poFeature;\n"
"    while( (poFeature = poLayer->GetNextFeature()) != NULL )\n"
"    {\n"
"        for( int iField = 0; iField < poFDefn->GetFieldCount(); iField++ )\n"
"        {\n"
"            if( !poFeature->IsFieldSet(iField) )\n"
"            {\n"
"                printf(\"(unset),\");\n"
"                continue;\n"
"            }\n"
"            if( poFeature->IsFieldNull(iField) )\n"
"            {\n"
"                printf(\"(null),\");\n"
"                continue;\n"
"            }\n"
"            OGRFieldDefn *poFieldDefn = poFDefn->GetFieldDefn( iField );\n"
"\n"
"            switch( poFieldDefn->GetType() )\n"
"            {\n"
"                case OFTInteger:\n"
"                    printf( \"%d,\", poFeature-"
">GetFieldAsInteger( iField ) );\n"
"                    break;\n"
"                case OFTInteger64:\n"
"                    printf( CPL_FRMT_GIB \",\", poFeature-"
">GetFieldAsInteger64( iField ) );\n"
"                    break;\n"
"                case OFTReal:\n"
"                    printf( \"%.3f,\", poFeature-"
">GetFieldAsDouble(iField) );\n"
"                    break;\n"
"                case OFTString:\n"
"                    printf( \"%s,\", poFeature->GetFieldAsString(iField) );\n"
"                    break;\n"
"                default:\n"
"                    printf( \"%s,\", poFeature->GetFieldAsString(iField) );\n"
"                    break;\n"
"            }\n"
"        }\n"
"\n"
"        OGRGeometry *poGeometry = poFeature->GetGeometryRef();\n"
"        if( poGeometry != NULL\n"
"                && wkbFlatten(poGeometry->getGeometryType()) == wkbPoint )\n"
"        {\n"
"            OGRPoint *poPoint = (OGRPoint *) poGeometry;\n"
"\n"
"            printf( \"%.3f,%3.f\\n\", poPoint->getX(), poPoint->getY() );\n"
"        }\n"
"        else\n"
"        {\n"
"            printf( \"no point geometry\\n\" );\n"
"        }\n"
"        OGRFeature::DestroyFeature( poFeature );\n"
"    }\n"
"\n"
"    GDALClose( poDS );\n"
"}"
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:617
msgid ""
"#include \"gdal.h\"\n"
"\n"
"int main()\n"
"\n"
"{\n"
"    GDALAllRegister();\n"
"\n"
"    GDALDatasetH hDS;\n"
"    OGRLayerH hLayer;\n"
"    OGRFeatureH hFeature;\n"
"    OGRFeatureDefnH hFDefn;\n"
"\n"
"    hDS = GDALOpenEx( \"point.shp\", GDAL_OF_VECTOR, NULL, NULL, NULL );\n"
"    if( hDS == NULL )\n"
"    {\n"
"        printf( \"Open failed.\\n\" );\n"
"        exit( 1 );\n"
"    }\n"
"\n"
"    hLayer = GDALDatasetGetLayerByName( hDS, \"point\" );\n"
"    hFDefn = OGR_L_GetLayerDefn(hLayer);\n"
"\n"
"    OGR_L_ResetReading(hLayer);\n"
"    while( (hFeature = OGR_L_GetNextFeature(hLayer)) != NULL )\n"
"    {\n"
"        int iField;\n"
"        OGRGeometryH hGeometry;\n"
"\n"
"        for( iField = 0; iField < OGR_FD_GetFieldCount(hFDefn); iField++ )\n"
"        {\n"
"            OGRFieldDefnH hFieldDefn = OGR_FD_GetFieldDefn( hFDefn, "
"iField );\n"
"\n"
"            if( !OGR_F_IsFieldSet(hFeature, iField) )\n"
"            {\n"
"                printf(\"(unset),\");\n"
"                continue;\n"
"            }\n"
"            if( OGR_F_IsFieldNull(hFeature, iField) )\n"
"            {\n"
"                printf(\"(null),\");\n"
"                continue;\n"
"            }\n"
"\n"
"            switch( OGR_Fld_GetType(hFieldDefn) )\n"
"            {\n"
"                case OFTInteger:\n"
"                    printf( \"%d,\", OGR_F_GetFieldAsInteger( hFeature, "
"iField ) );\n"
"                    break;\n"
"                case OFTInteger64:\n"
"                    printf( CPL_FRMT_GIB \",\", "
"OGR_F_GetFieldAsInteger64( hFeature, iField ) );\n"
"                    break;\n"
"                case OFTReal:\n"
"                    printf( \"%.3f,\", OGR_F_GetFieldAsDouble( hFeature, "
"iField) );\n"
"                    break;\n"
"                case OFTString:\n"
"                    printf( \"%s,\", OGR_F_GetFieldAsString( hFeature, "
"iField) );\n"
"                    break;\n"
"                default:\n"
"                    printf( \"%s,\", OGR_F_GetFieldAsString( hFeature, "
"iField) );\n"
"                    break;\n"
"            }\n"
"        }\n"
"\n"
"        hGeometry = OGR_F_GetGeometryRef(hFeature);\n"
"        if( hGeometry != NULL\n"
"            && wkbFlatten(OGR_G_GetGeometryType(hGeometry)) == wkbPoint )\n"
"        {\n"
"            printf( \"%.3f,%3.f\\n\", OGR_G_GetX(hGeometry, 0), "
"OGR_G_GetY(hGeometry, 0) );\n"
"        }\n"
"        else\n"
"        {\n"
"            printf( \"no point geometry\\n\" );\n"
"        }\n"
"\n"
"        OGR_F_Destroy( hFeature );\n"
"    }\n"
"\n"
"    GDALClose( hDS );\n"
"}"
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:702
msgid ""
"import sys\n"
"from osgeo import gdal\n"
"\n"
"ds = gdal.OpenEx( \"point.shp\", gdal.OF_VECTOR )\n"
"if ds is None:\n"
"    print \"Open failed.\\n\"\n"
"    sys.exit( 1 )\n"
"\n"
"lyr = ds.GetLayerByName( \"point\" )\n"
"\n"
"lyr.ResetReading()\n"
"\n"
"for feat in lyr:\n"
"\n"
"    feat_defn = lyr.GetLayerDefn()\n"
"    for i in range(feat_defn.GetFieldCount()):\n"
"        field_defn = feat_defn.GetFieldDefn(i)\n"
"\n"
"        # Tests below can be simplified with just :\n"
"        # print feat.GetField(i)\n"
"        if field_defn.GetType() == ogr.OFTInteger or field_defn.GetType() == "
"ogr.OFTInteger64:\n"
"            print \"%d\" % feat.GetFieldAsInteger64(i)\n"
"        elif field_defn.GetType() == ogr.OFTReal:\n"
"            print \"%.3f\" % feat.GetFieldAsDouble(i)\n"
"        elif field_defn.GetType() == ogr.OFTString:\n"
"            print \"%s\" % feat.GetFieldAsString(i)\n"
"        else:\n"
"            print \"%s\" % feat.GetFieldAsString(i)\n"
"\n"
"    geom = feat.GetGeometryRef()\n"
"    if geom is not None and geom.GetGeometryType() == ogr.wkbPoint:\n"
"        print \"%.3f, %.3f\" % ( geom.GetX(), geom.GetY() )\n"
"    else:\n"
"        print \"no point geometry\\n\"\n"
"\n"
"ds = None"
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:744
msgid "Reading From OGR using the Arrow C Stream data interface"
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:748
msgid ""
"Instead of retrieving features one at a time, it is also possible to "
"retrieve them by batches, with a column-oriented memory layout, using the :"
"cpp:func:`OGRLayer::GetArrowStream` method. Note that this method is more "
"difficult to use than the traditional :cpp:func:`OGRLayer::GetNextFeature` "
"approach, and is only advised when compatibility with the `Apache Arrow C "
"Stream interface <https://arrow.apache.org/docs/format/CStreamInterface."
"html>`_ is needed, or when column-oriented consumption of layers is required."
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:756
msgid ""
"Pending using an helper library, consumption of the Arrow C Stream interface "
"requires reading of the following documents:"
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:759
msgid ""
"`Arrow C Stream interface <https://arrow.apache.org/docs/format/"
"CStreamInterface.html>`_"
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:760
#: ../../../source/tutorials/vector_api_tut.rst:1686
msgid ""
"`Arrow C data interface <https://arrow.apache.org/docs/format/CDataInterface."
"html>`_"
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:761
#: ../../../source/tutorials/vector_api_tut.rst:1687
msgid ""
"`Arrow Columnar Format <https://arrow.apache.org/docs/format/Columnar."
"html>`_."
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:763
msgid ""
"The Arrow C Stream interface interface consists of a set of C structures, "
"ArrowArrayStream, that provides two main callbacks to get:"
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:766
msgid ""
"a ArrowSchema with the get_schema() callback. A ArrowSchema describes a set "
"of field descriptions (name, type, metadata). All OGR data types have a "
"corresponding Arrow data type."
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:770
msgid ""
"a sequence of ArrowArray with the get_next() callback. A ArrowArray captures "
"a set of values for a specific column/field in a subset of features. This is "
"the equivalent of a `Series <https://arrow.apache.org/docs/python/pandas."
"html#series>`_ in a Pandas DataFrame. This is a potentially hiearchical "
"structure that can aggregate sub arrays, and in OGR usage, the main array "
"will be a StructArray which is the collection of OGR attribute and geometry "
"fields. The layout of buffers and children arrays per data type is detailed "
"in the `Arrow Columnar Format <https://arrow.apache.org/docs/format/Columnar."
"html>`_."
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:780
msgid ""
"If a layer consists of 4 features with 2 fields (one of integer type, one of "
"floating-point type), the representation as a ArrowArray is *conceptually* "
"the following one:"
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:784
msgid ""
"array.children[0].buffers[1] = { 1, 2, 3, 4 };\n"
"array.children[1].buffers[1] = { 1.2, 2.3, 3.4, 4.5 };"
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:789
msgid ""
"The content of a whole layer can be seen as a sequence of record batches, "
"each record batches being an ArrowArray of a subset of features. Instead of "
"iterating over individual features, one iterates over a batch of several "
"features at once."
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:794
msgid ""
"The ArrowArrayStream, ArrowSchema, ArrowArray structures are defined in a "
"ogr_recordbatch.h public header file, directly derived from https://github."
"com/apache/arrow/blob/main/cpp/src/arrow/c/abi.h to get API/ABI "
"compatibility with Apache Arrow C++. This header file must be explicitly "
"included when the related array batch API is used."
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:800
msgid "The GetArrowStream() method has the following signature:"
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:802
msgid ""
"virtual bool OGRLayer::GetArrowStream(struct ArrowArrayStream* out_stream,\n"
"                                      CSLConstList papszOptions = nullptr);"
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:807
msgid "It is also available in the C API as :cpp:func:`OGR_L_GetArrowStream`."
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:809
msgid ""
"out_stream is a pointer to a ArrowArrayStream structure, that can be in a "
"uninitialized state (the method will ignore any initial content)."
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:812
msgid ""
"On successful return, and when the stream interfaces is no longer needed, it "
"must must be freed with out_stream->release(out_stream)."
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:815
msgid ""
"There are extra precautions to take into account in a OGR context. Unless "
"otherwise specified by a particular driver implementation, the "
"ArrowArrayStream structure, and the ArrowSchema or ArrowArray objects its "
"callbacks have returned, should no longer be used (except for potentially "
"being released) after the OGRLayer from which it was initialized has been "
"destroyed (typically at dataset closing). Furthermore, unless otherwise "
"specified by a particular driver implementation, only one ArrowArrayStream "
"can be active at a time on a given layer (that is the last active one must "
"be explicitly released before a next one is asked). Changing filter state, "
"ignored columns, modifying the schema or using ResetReading()/"
"GetNextFeature() while using a ArrowArrayStream is strongly discouraged and "
"may lead to unexpected results. As a rule of thumb, no OGRLayer methods that "
"affect the state of a layer should be called on a layer, while an "
"ArrowArrayStream on it is active."
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:829
msgid ""
"The papszOptions that may be provided is a NULL terminated list of key=value "
"strings, that may be driver specific."
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:832
msgid "OGRLayer has a base implementation of GetArrowStream() that is such:"
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:834
msgid ""
"The get_schema() callback returns a schema whose top-level object returned "
"is of type Struct, and whose children consist of the FID column, all OGR "
"attribute fields and geometry fields to Arrow fields. The FID column may be "
"omitted by providing the INCLUDE_FID=NO option."
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:839
msgid ""
"When get_schema() returns 0, and the schema is no longer needed, it must be "
"released with the following procedure, to take into account that it might "
"have been released by other code, as documented in the Arrow C data "
"interface:"
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:844
msgid ""
"if( out_schema->release )\n"
"    out_schema->release(out_schema)"
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:850
msgid "The get_next() callback retrieve the next record batch over the layer."
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:852
msgid ""
"out_array is a pointer to a ArrowArray structure, that can be in a "
"uninitialized state (the method will ignore any initial content)."
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:855
msgid ""
"The default implementation uses GetNextFeature() internally to retrieve "
"batches of up to 65,536 features (configurable with the "
"MAX_FEATURES_IN_BATCH=num option). The starting address of buffers allocated "
"by the default implementation is aligned on 64-byte boundaries."
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:860
msgid ""
"The default implementation outputs geometries as WKB in a binary field, "
"whose corresponding entry in the schema is marked with the metadata item "
"``ARROW:extension:name`` set to ``ogc.wkb``. Specialized implementations may "
"output by default other formats (particularly the Arrow driver that can "
"return geometries encoded according to the GeoArrow specification (using a "
"list of coordinates). The GEOMETRY_ENCODING=WKB option can be passed to "
"force the use of WKB (through the default implementation)"
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:868
msgid ""
"The method may take into account ignored fields set with SetIgnoredFields() "
"(the default implementation does), and should take into account filters set "
"with SetSpatialFilter() and SetAttributeFilter(). Note however that "
"specialized implementations may fallback to the default (slower) "
"implementation when filters are set."
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:873
msgid ""
"Mixing calls to GetNextFeature() and get_next() is not recommended, as the "
"behavior will be unspecified (but it should not crash)."
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:876
msgid ""
"When get_next() returns 0, and the array is no longer needed, it must be "
"released with the following procedure, to take into account that it might "
"have been released by other code, as documented in the Arrow C data "
"interface:"
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:881
msgid ""
"if( out_array->release )\n"
"    out_array->release(out_array)"
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:886
msgid ""
"Drivers that have a specialized implementation advertise the new "
"OLCFastGetArrowStream layer capability."
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:889
msgid ""
"Using directly (as a producer or a consumer) a ArrowArray is admittedly not "
"trivial, and requires good intimacy with the Arrow C data interface and "
"columnar array specifications, to know, in which buffer of an array, data is "
"to be read, which data type void* buffers should be cast to, how to use "
"buffers that contain null/not_null information, how to use offset buffers "
"for data types of type List, etc. The study of the gdal_array."
"_RecordBatchAsNumpy() method of the SWIG Python bindings (:source_file:`swig/"
"include/gdal_array.i`) can give a good hint of how to use an ArrowArray "
"object, in conjunction with the associated ArrowSchema."
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:899
msgid ""
"The below example illustrates how to read the content of a layer that "
"consists of a integer field and a geometry field:"
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:903
msgid ""
"#include \"gdal_priv.h\"\n"
"#include \"ogr_api.h\"\n"
"#include \"ogrsf_frmts.h\"\n"
"#include \"ogr_recordbatch.h\"\n"
"#include <cassert>\n"
"\n"
"int main(int argc, char* argv[])\n"
"{\n"
"    GDALAllRegister();\n"
"    GDALDataset* poDS = GDALDataset::Open(argv[1]);\n"
"    if( poDS == nullptr )\n"
"    {\n"
"        CPLError(CE_Failure, CPLE_AppDefined, \"Open() failed\\n\");\n"
"        exit(1);\n"
"    }\n"
"    OGRLayer* poLayer = poDS->GetLayer(0);\n"
"    OGRLayerH hLayer = OGRLayer::ToHandle(poLayer);\n"
"\n"
"    // Get the Arrow stream\n"
"    struct ArrowArrayStream stream;\n"
"    if( !OGR_L_GetArrowStream(hLayer, &stream, nullptr))\n"
"    {\n"
"        CPLError(CE_Failure, CPLE_AppDefined, \"OGR_L_GetArrowStream() "
"failed\\n\");\n"
"        delete poDS;\n"
"        exit(1);\n"
"    }\n"
"\n"
"    // Get the schema\n"
"    struct ArrowSchema schema;\n"
"    if( stream.get_schema(&stream, &schema) != 0 )\n"
"    {\n"
"        CPLError(CE_Failure, CPLE_AppDefined, \"get_schema() failed\\n\");\n"
"        stream.release(&stream);\n"
"        delete poDS;\n"
"        exit(1);\n"
"    }\n"
"\n"
"    // Check that the returned schema consists of one int64 field (for "
"FID),\n"
"    // one int32 field and one binary/wkb field\n"
"    if( schema.n_children != 3 ||\n"
"        strcmp(schema.children[0]->format, \"l\") != 0 || // int64 -> FID\n"
"        strcmp(schema.children[1]->format, \"i\") != 0 || // int32\n"
"        strcmp(schema.children[2]->format, \"z\") != 0 )  // binary for WKB\n"
"    {\n"
"        CPLError(CE_Failure, CPLE_AppDefined,\n"
"                 \"Layer has not the expected schema required by this "
"example.\");\n"
"        schema.release(&schema);\n"
"        stream.release(&stream);\n"
"        delete poDS;\n"
"        exit(1);\n"
"    }\n"
"    schema.release(&schema);\n"
"\n"
"    // Iterate over batches\n"
"    while( true )\n"
"    {\n"
"        struct ArrowArray array;\n"
"        if( stream.get_next(&stream, &array) != 0 ||\n"
"            array.release == nullptr )\n"
"        {\n"
"            break;\n"
"        }\n"
"\n"
"        assert(array.n_children == 3);\n"
"\n"
"        // Cast the array->children[].buffers[] to the appropriate data "
"types\n"
"        const auto int_child = array.children[1];\n"
"        assert(int_child->n_buffers == 2);\n"
"        const uint8_t* int_field_not_null = static_cast<const "
"uint8_t*>(int_child->buffers[0]);\n"
"        const int32_t* int_field = static_cast<const int32_t*>(int_child-"
">buffers[1]);\n"
"\n"
"        const auto wkb_child = array.children[2];\n"
"        assert(wkb_child->n_buffers == 3);\n"
"        const uint8_t* wkb_field_not_null = static_cast<const "
"uint8_t*>(wkb_child->buffers[0]);\n"
"        const int32_t* wkb_offset = static_cast<const int32_t*>(wkb_child-"
">buffers[1]);\n"
"        const uint8_t* wkb_field = static_cast<const uint8_t*>(wkb_child-"
">buffers[2]);\n"
"\n"
"        // Lambda to check if a field is set for a given feature index\n"
"        const auto IsSet = [](const uint8_t* buffer_not_null, int i)\n"
"        {\n"
"            return buffer_not_null == nullptr || (buffer_not_null[i/8] >> "
"(i%8)) != 0;\n"
"        };\n"
"\n"
"        // Iterate through features of a batch\n"
"        for( long long i = 0; i < array.length; i++ )\n"
"        {\n"
"            if( IsSet(int_field_not_null, i) )\n"
"                printf(\"int_field[%lld] = %d\\n\", i, int_field[i]);\n"
"            else\n"
"                printf(\"int_field[%lld] = null\\n\", i);\n"
"\n"
"            if( IsSet(wkb_field_not_null, i) )\n"
"            {\n"
"                const void* wkb = wkb_field + wkb_offset[i];\n"
"                const int32_t length = wkb_offset[i+1] - wkb_offset[i];\n"
"                char* wkt = nullptr;\n"
"                OGRGeometry* geom = nullptr;\n"
"                OGRGeometryFactory::createFromWkb(wkb, nullptr, &geom, "
"length);\n"
"                if( geom )\n"
"                {\n"
"                    geom->exportToWkt(&wkt);\n"
"                }\n"
"                printf(\"wkb_field[%lld] = %s\\n\", i, wkt ? wkt : \"invalid "
"geometry\");\n"
"                CPLFree(wkt);\n"
"                delete geom;\n"
"            }\n"
"            else\n"
"            {\n"
"                printf(\"wkb_field[%lld] = null\\n\", i);\n"
"            }\n"
"        }\n"
"\n"
"        // Release memory taken by the batch\n"
"        array.release(&array);\n"
"    }\n"
"\n"
"    // Release stream and dataset\n"
"    stream.release(&stream);\n"
"    delete poDS;\n"
"    return 0;\n"
"}"
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:1028
msgid ""
"To write features by batches using an ArrowArray, consult :ref:"
"`vector_api_tut_arrow_write`."
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:1031
msgid "Writing To OGR"
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:1033
msgid ""
"As an example of writing through OGR, we will do roughly the opposite of the "
"above.  A short program that reads comma separated values from input text "
"will be written to a point shapefile via OGR."
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:1037
msgid ""
"As usual, we start by registering all the drivers, and then fetch the "
"Shapefile driver as we will need it to create our output file."
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:1042
msgid ""
"#include \"ogrsf_frmts.h\"\n"
"\n"
"int main()\n"
"{\n"
"    const char *pszDriverName = \"ESRI Shapefile\";\n"
"    GDALDriver *poDriver;\n"
"\n"
"    GDALAllRegister();\n"
"\n"
"    poDriver = GetGDALDriverManager()->GetDriverByName(pszDriverName );\n"
"    if( poDriver == NULL )\n"
"    {\n"
"        printf( \"%s driver not available.\\n\", pszDriverName );\n"
"        exit( 1 );\n"
"    }"
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:1062
msgid ""
"#include \"ogr_api.h\"\n"
"\n"
"int main()\n"
"{\n"
"    const char *pszDriverName = \"ESRI Shapefile\";\n"
"    GDALDriver *poDriver;\n"
"\n"
"    GDALAllRegister();\n"
"\n"
"    poDriver = (GDALDriver*) GDALGetDriverByName(pszDriverName );\n"
"    if( poDriver == NULL )\n"
"    {\n"
"        printf( \"%s driver not available.\\n\", pszDriverName );\n"
"        exit( 1 );\n"
"    }"
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:1080
msgid ""
"Next we create the datasource.  The ESRI Shapefile driver allows us to "
"create a directory full of shapefiles, or a single shapefile as a "
"datasource.  In this case we will explicitly create a single file by "
"including the extension in the name.  Other drivers behave differently. The "
"second, third, fourth and fifth argument are related to raster dimensions "
"(in case the driver has raster capabilities). The last argument to the call "
"is a list of option values, but we will just be using defaults in this "
"case.  Details of the options supported are also format specific."
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:1089
msgid "In C ++ :"
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:1091
msgid ""
"GDALDataset *poDS;\n"
"\n"
"poDS = poDriver->Create( \"point_out.shp\", 0, 0, 0, GDT_Unknown, NULL );\n"
"if( poDS == NULL )\n"
"{\n"
"    printf( \"Creation of output file failed.\\n\" );\n"
"    exit( 1 );\n"
"}"
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:1105
msgid ""
"GDALDatasetH hDS;\n"
"\n"
"hDS = GDALCreate( hDriver, \"point_out.shp\", 0, 0, 0, GDT_Unknown, NULL );\n"
"if( hDS == NULL )\n"
"{\n"
"    printf( \"Creation of output file failed.\\n\" );\n"
"    exit( 1 );\n"
"}"
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:1116
msgid ""
"Now we create the output layer.  In this case since the datasource is a "
"single file, we can only have one layer.  We pass wkbPoint to specify the "
"type of geometry supported by this layer.  In this case we aren't passing "
"any coordinate system information or other special layer creation options."
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:1123
msgid ""
"OGRLayer *poLayer;\n"
"\n"
"poLayer = poDS->CreateLayer( \"point_out\", NULL, wkbPoint, NULL );\n"
"if( poLayer == NULL )\n"
"{\n"
"    printf( \"Layer creation failed.\\n\" );\n"
"    exit( 1 );\n"
"}"
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:1137
msgid ""
"OGRLayerH hLayer;\n"
"\n"
"hLayer = GDALDatasetCreateLayer( hDS, \"point_out\", NULL, wkbPoint, "
"NULL );\n"
"if( hLayer == NULL )\n"
"{\n"
"    printf( \"Layer creation failed.\\n\" );\n"
"    exit( 1 );\n"
"}"
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:1149
msgid ""
"Now that the layer exists, we need to create any attribute fields that "
"should appear on the layer.  Fields must be added to the layer before any "
"features are written.  To create a field we initialize an :cpp:union:"
"`OGRField` object with the information about the field.  In the case of "
"Shapefiles, the field width and precision is significant in the creation of "
"the output .dbf file, so we set it specifically, though generally the "
"defaults are OK.  For this example we will just have one attribute, a name "
"string associated with the x,y point."
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:1157
msgid ""
"Note that the template OGRField we pass to :cpp:func:`OGRLayer::CreateField` "
"is copied internally. We retain ownership of the object."
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:1160
msgid "In C++:"
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:1162
msgid ""
"OGRFieldDefn oField( \"Name\", OFTString );\n"
"\n"
"oField.SetWidth(32);\n"
"\n"
"if( poLayer->CreateField( &oField ) != OGRERR_NONE )\n"
"{\n"
"    printf( \"Creating Name field failed.\\n\" );\n"
"    exit( 1 );\n"
"}"
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:1175
msgid "In C:"
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:1177
msgid ""
"OGRFieldDefnH hFieldDefn;\n"
"\n"
"hFieldDefn = OGR_Fld_Create( \"Name\", OFTString );\n"
"\n"
"OGR_Fld_SetWidth( hFieldDefn, 32);\n"
"\n"
"if( OGR_L_CreateField( hLayer, hFieldDefn, TRUE ) != OGRERR_NONE )\n"
"{\n"
"    printf( \"Creating Name field failed.\\n\" );\n"
"    exit( 1 );\n"
"}\n"
"\n"
"OGR_Fld_Destroy(hFieldDefn);"
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:1194
msgid ""
"The following snipping loops reading lines of the form \"x,y,name\" from "
"stdin, and parsing them."
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:1197
msgid "In C++ and in C :"
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:1199
msgid ""
"double x, y;\n"
"char szName[33];\n"
"\n"
"while( !feof(stdin)\n"
"       && fscanf( stdin, \"%lf,%lf,%32s\", &x, &y, szName ) == 3 )\n"
"{"
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:1208
msgid ""
"To write a feature to disk, we must create a local OGRFeature, set "
"attributes and attach geometry before trying to write it to the layer.  It "
"is imperative that this feature be instantiated from the OGRFeatureDefn "
"associated with the layer it will be written to."
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:1215
msgid ""
"OGRFeature *poFeature;\n"
"\n"
"poFeature = OGRFeature::CreateFeature( poLayer->GetLayerDefn() );\n"
"poFeature->SetField( \"Name\", szName );"
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:1224
msgid ""
"OGRFeatureH hFeature;\n"
"\n"
"hFeature = OGR_F_Create( OGR_L_GetLayerDefn( hLayer ) );\n"
"OGR_F_SetFieldString( hFeature, OGR_F_GetFieldIndex(hFeature, \"Name\"), "
"szName );"
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:1231
msgid ""
"We create a local geometry object, and assign its copy (indirectly) to the "
"feature. The :cpp:func:`OGRFeature::SetGeometryDirectly` differs from :cpp:"
"func:`OGRFeature::SetGeometry` in that the direct method gives ownership of "
"the geometry to the feature. This is generally more efficient as it avoids "
"an extra deep object copy of the geometry."
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:1239
msgid ""
"OGRPoint pt;\n"
"pt.setX( x );\n"
"pt.setY( y );\n"
"\n"
"poFeature->SetGeometry( &pt );"
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:1250
msgid ""
"OGRGeometryH hPt;\n"
"hPt = OGR_G_CreateGeometry(wkbPoint);\n"
"OGR_G_SetPoint_2D(hPt, 0, x, y);\n"
"\n"
"OGR_F_SetGeometry( hFeature, hPt );\n"
"OGR_G_DestroyGeometry(hPt);"
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:1260
msgid ""
"Now we create a feature in the file.  The :cpp:func:`OGRLayer::"
"CreateFeature` does not take ownership of our feature so we clean it up when "
"done with it."
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:1265
msgid ""
"     if( poLayer->CreateFeature( poFeature ) != OGRERR_NONE )\n"
"     {\n"
"         printf( \"Failed to create feature in shapefile.\\n\" );\n"
"        exit( 1 );\n"
"     }\n"
"\n"
"     OGRFeature::DestroyFeature( poFeature );\n"
"}"
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:1278
msgid ""
"     if( OGR_L_CreateFeature( hLayer, hFeature ) != OGRERR_NONE )\n"
"     {\n"
"         printf( \"Failed to create feature in shapefile.\\n\" );\n"
"        exit( 1 );\n"
"     }\n"
"\n"
"     OGR_F_Destroy( hFeature );\n"
"}"
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:1290
msgid ""
"Finally we need to close down the datasource in order to ensure headers are "
"written out in an orderly way and all resources are recovered."
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:1301
msgid "The same program all in one block looks like this:"
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:1305
msgid ""
"#include \"ogrsf_frmts.h\"\n"
"\n"
"int main()\n"
"{\n"
"    const char *pszDriverName = \"ESRI Shapefile\";\n"
"    GDALDriver *poDriver;\n"
"\n"
"    GDALAllRegister();\n"
"\n"
"    poDriver = GetGDALDriverManager()->GetDriverByName(pszDriverName );\n"
"    if( poDriver == NULL )\n"
"    {\n"
"        printf( \"%s driver not available.\\n\", pszDriverName );\n"
"        exit( 1 );\n"
"    }\n"
"\n"
"    GDALDataset *poDS;\n"
"\n"
"    poDS = poDriver->Create( \"point_out.shp\", 0, 0, 0, GDT_Unknown, "
"NULL );\n"
"    if( poDS == NULL )\n"
"    {\n"
"        printf( \"Creation of output file failed.\\n\" );\n"
"        exit( 1 );\n"
"    }\n"
"\n"
"    OGRLayer *poLayer;\n"
"\n"
"    poLayer = poDS->CreateLayer( \"point_out\", NULL, wkbPoint, NULL );\n"
"    if( poLayer == NULL )\n"
"    {\n"
"        printf( \"Layer creation failed.\\n\" );\n"
"        exit( 1 );\n"
"    }\n"
"\n"
"    OGRFieldDefn oField( \"Name\", OFTString );\n"
"\n"
"    oField.SetWidth(32);\n"
"\n"
"    if( poLayer->CreateField( &oField ) != OGRERR_NONE )\n"
"    {\n"
"        printf( \"Creating Name field failed.\\n\" );\n"
"        exit( 1 );\n"
"    }\n"
"\n"
"    double x, y;\n"
"    char szName[33];\n"
"\n"
"    while( !feof(stdin)\n"
"        && fscanf( stdin, \"%lf,%lf,%32s\", &x, &y, szName ) == 3 )\n"
"    {\n"
"        OGRFeature *poFeature;\n"
"\n"
"        poFeature = OGRFeature::CreateFeature( poLayer->GetLayerDefn() );\n"
"        poFeature->SetField( \"Name\", szName );\n"
"\n"
"        OGRPoint pt;\n"
"\n"
"        pt.setX( x );\n"
"        pt.setY( y );\n"
"\n"
"        poFeature->SetGeometry( &pt );\n"
"\n"
"        if( poLayer->CreateFeature( poFeature ) != OGRERR_NONE )\n"
"        {\n"
"            printf( \"Failed to create feature in shapefile.\\n\" );\n"
"            exit( 1 );\n"
"        }\n"
"\n"
"        OGRFeature::DestroyFeature( poFeature );\n"
"    }\n"
"\n"
"    GDALClose( poDS );\n"
"}"
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:1384
msgid ""
"#include \"gdal.h\"\n"
"\n"
"int main()\n"
"{\n"
"    const char *pszDriverName = \"ESRI Shapefile\";\n"
"    GDALDriverH hDriver;\n"
"    GDALDatasetH hDS;\n"
"    OGRLayerH hLayer;\n"
"    OGRFieldDefnH hFieldDefn;\n"
"    double x, y;\n"
"    char szName[33];\n"
"\n"
"    GDALAllRegister();\n"
"\n"
"    hDriver = GDALGetDriverByName( pszDriverName );\n"
"    if( hDriver == NULL )\n"
"    {\n"
"        printf( \"%s driver not available.\\n\", pszDriverName );\n"
"        exit( 1 );\n"
"    }\n"
"\n"
"    hDS = GDALCreate( hDriver, \"point_out.shp\", 0, 0, 0, GDT_Unknown, "
"NULL );\n"
"    if( hDS == NULL )\n"
"    {\n"
"        printf( \"Creation of output file failed.\\n\" );\n"
"        exit( 1 );\n"
"    }\n"
"\n"
"    hLayer = GDALDatasetCreateLayer( hDS, \"point_out\", NULL, wkbPoint, "
"NULL );\n"
"    if( hLayer == NULL )\n"
"    {\n"
"        printf( \"Layer creation failed.\\n\" );\n"
"        exit( 1 );\n"
"    }\n"
"\n"
"    hFieldDefn = OGR_Fld_Create( \"Name\", OFTString );\n"
"\n"
"    OGR_Fld_SetWidth( hFieldDefn, 32);\n"
"\n"
"    if( OGR_L_CreateField( hLayer, hFieldDefn, TRUE ) != OGRERR_NONE )\n"
"    {\n"
"        printf( \"Creating Name field failed.\\n\" );\n"
"        exit( 1 );\n"
"    }\n"
"\n"
"    OGR_Fld_Destroy(hFieldDefn);\n"
"\n"
"    while( !feof(stdin)\n"
"        && fscanf( stdin, \"%lf,%lf,%32s\", &x, &y, szName ) == 3 )\n"
"    {\n"
"        OGRFeatureH hFeature;\n"
"        OGRGeometryH hPt;\n"
"\n"
"        hFeature = OGR_F_Create( OGR_L_GetLayerDefn( hLayer ) );\n"
"        OGR_F_SetFieldString( hFeature, OGR_F_GetFieldIndex(hFeature, "
"\"Name\"), szName );\n"
"\n"
"        hPt = OGR_G_CreateGeometry(wkbPoint);\n"
"        OGR_G_SetPoint_2D(hPt, 0, x, y);\n"
"\n"
"        OGR_F_SetGeometry( hFeature, hPt );\n"
"        OGR_G_DestroyGeometry(hPt);\n"
"\n"
"        if( OGR_L_CreateFeature( hLayer, hFeature ) != OGRERR_NONE )\n"
"        {\n"
"        printf( \"Failed to create feature in shapefile.\\n\" );\n"
"        exit( 1 );\n"
"        }\n"
"\n"
"        OGR_F_Destroy( hFeature );\n"
"    }\n"
"\n"
"    GDALClose( hDS );\n"
"}"
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:1461
#: ../../../source/tutorials/vector_api_tut.rst:1653
msgid "In Python :"
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:1463
msgid ""
"import sys\n"
"from osgeo import gdal\n"
"from osgeo import ogr\n"
"import string\n"
"\n"
"driverName = \"ESRI Shapefile\"\n"
"drv = gdal.GetDriverByName( driverName )\n"
"if drv is None:\n"
"    print \"%s driver not available.\\n\" % driverName\n"
"    sys.exit( 1 )\n"
"\n"
"ds = drv.Create( \"point_out.shp\", 0, 0, 0, gdal.GDT_Unknown )\n"
"if ds is None:\n"
"    print \"Creation of output file failed.\\n\"\n"
"    sys.exit( 1 )\n"
"\n"
"lyr = ds.CreateLayer( \"point_out\", None, ogr.wkbPoint )\n"
"if lyr is None:\n"
"    print \"Layer creation failed.\\n\"\n"
"    sys.exit( 1 )\n"
"\n"
"field_defn = ogr.FieldDefn( \"Name\", ogr.OFTString )\n"
"field_defn.SetWidth( 32 )\n"
"\n"
"if lyr.CreateField ( field_defn ) != 0:\n"
"    print \"Creating Name field failed.\\n\"\n"
"    sys.exit( 1 )\n"
"\n"
"# Expected format of user input: x y name\n"
"linestring = raw_input()\n"
"linelist = string.split(linestring)\n"
"\n"
"while len(linelist) == 3:\n"
"    x = float(linelist[0])\n"
"    y = float(linelist[1])\n"
"    name = linelist[2]\n"
"\n"
"    feat = ogr.Feature( lyr.GetLayerDefn())\n"
"    feat.SetField( \"Name\", name )\n"
"\n"
"    pt = ogr.Geometry(ogr.wkbPoint)\n"
"    pt.SetPoint_2D(0, x, y)\n"
"\n"
"    feat.SetGeometry(pt)\n"
"\n"
"    if lyr.CreateFeature(feat) != 0:\n"
"        print \"Failed to create feature in shapefile.\\n\"\n"
"        sys.exit( 1 )\n"
"\n"
"    feat.Destroy()\n"
"\n"
"    linestring = raw_input()\n"
"    linelist = string.split(linestring)\n"
"\n"
"ds = None"
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:1522
msgid ""
"Several geometry fields can be associated to a feature. This capability is "
"just available for a few file formats, such as PostGIS."
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:1525
msgid ""
"To create such datasources, geometry fields must be first created. Spatial "
"reference system objects can be associated to each geometry field."
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:1530
msgid ""
"OGRGeomFieldDefn oPointField( \"PointField\", wkbPoint );\n"
"OGRSpatialReference* poSRS = new OGRSpatialReference();\n"
"poSRS->importFromEPSG(4326);\n"
"oPointField.SetSpatialRef(poSRS);\n"
"poSRS->Release();\n"
"\n"
"if( poLayer->CreateGeomField( &oPointField ) != OGRERR_NONE )\n"
"{\n"
"    printf( \"Creating field PointField failed.\\n\" );\n"
"    exit( 1 );\n"
"}\n"
"\n"
"OGRGeomFieldDefn oFieldPoint2( \"PointField2\", wkbPoint );\n"
"poSRS = new OGRSpatialReference();\n"
"poSRS->importFromEPSG(32631);\n"
"oPointField2.SetSpatialRef(poSRS);\n"
"poSRS->Release();\n"
"\n"
"if( poLayer->CreateGeomField( &oPointField2 ) != OGRERR_NONE )\n"
"{\n"
"    printf( \"Creating field PointField2 failed.\\n\" );\n"
"    exit( 1 );\n"
"}"
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:1559
msgid ""
"OGRGeomFieldDefnH hPointField;\n"
"OGRGeomFieldDefnH hPointField2;\n"
"OGRSpatialReferenceH hSRS;\n"
"\n"
"hPointField = OGR_GFld_Create( \"PointField\", wkbPoint );\n"
"hSRS = OSRNewSpatialReference( NULL );\n"
"OSRImportFromEPSG(hSRS, 4326);\n"
"OGR_GFld_SetSpatialRef(hPointField, hSRS);\n"
"OSRRelease(hSRS);\n"
"\n"
"if( OGR_L_CreateGeomField( hLayer, hPointField ) != OGRERR_NONE )\n"
"{\n"
"    printf( \"Creating field PointField failed.\\n\" );\n"
"    exit( 1 );\n"
"}\n"
"\n"
"OGR_GFld_Destroy( hPointField );\n"
"\n"
"hPointField2 = OGR_GFld_Create( \"PointField2\", wkbPoint );\n"
"OSRImportFromEPSG(hSRS, 32631);\n"
"OGR_GFld_SetSpatialRef(hPointField2, hSRS);\n"
"OSRRelease(hSRS);\n"
"\n"
"if( OGR_L_CreateGeomField( hLayer, hPointField2 ) != OGRERR_NONE )\n"
"{\n"
"    printf( \"Creating field PointField2 failed.\\n\" );\n"
"    exit( 1 );\n"
"}\n"
"\n"
"OGR_GFld_Destroy( hPointField2 );"
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:1593
msgid ""
"To write a feature to disk, we must create a local OGRFeature, set "
"attributes and attach geometries before trying to write it to the layer.  It "
"is imperative that this feature be instantiated from the OGRFeatureDefn "
"associated with the layer it will be written to."
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:1600
msgid ""
"OGRFeature *poFeature;\n"
"OGRGeometry *poGeometry;\n"
"char* pszWKT;\n"
"\n"
"poFeature = OGRFeature::CreateFeature( poLayer->GetLayerDefn() );\n"
"\n"
"pszWKT = (char*) \"POINT (2 49)\";\n"
"OGRGeometryFactory::createFromWkt( &pszWKT, NULL, &poGeometry );\n"
"poFeature->SetGeomFieldDirectly( \"PointField\", poGeometry );\n"
"\n"
"pszWKT = (char*) \"POINT (500000 4500000)\";\n"
"OGRGeometryFactory::createFromWkt( &pszWKT, NULL, &poGeometry );\n"
"poFeature->SetGeomFieldDirectly( \"PointField2\", poGeometry );\n"
"\n"
"if( poLayer->CreateFeature( poFeature ) != OGRERR_NONE )\n"
"{\n"
"    printf( \"Failed to create feature.\\n\" );\n"
"    exit( 1 );\n"
"}\n"
"\n"
"OGRFeature::DestroyFeature( poFeature );"
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:1626
msgid ""
"OGRFeatureH hFeature;\n"
"OGRGeometryH hGeometry;\n"
"char* pszWKT;\n"
"\n"
"poFeature = OGR_F_Create( OGR_L_GetLayerDefn(hLayer) );\n"
"\n"
"pszWKT = (char*) \"POINT (2 49)\";\n"
"OGR_G_CreateFromWkt( &pszWKT, NULL, &hGeometry );\n"
"OGR_F_SetGeomFieldDirectly( hFeature,\n"
"    OGR_F_GetGeomFieldIndex(hFeature, \"PointField\"), hGeometry );\n"
"\n"
"pszWKT = (char*) \"POINT (500000 4500000)\";\n"
"OGR_G_CreateFromWkt( &pszWKT, NULL, &hGeometry );\n"
"OGR_F_SetGeomFieldDirectly( hFeature,\n"
"    OGR_F_GetGeomFieldIndex(hFeature, \"PointField2\"), hGeometry );\n"
"\n"
"if( OGR_L_CreateFeature( hFeature ) != OGRERR_NONE )\n"
"{\n"
"    printf( \"Failed to create feature.\\n\" );\n"
"    exit( 1 );\n"
"}\n"
"\n"
"OGR_F_Destroy( hFeature );"
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:1655
msgid ""
"feat = ogr.Feature( lyr.GetLayerDefn() )\n"
"\n"
"feat.SetGeomFieldDirectly( \"PointField\",\n"
"    ogr.CreateGeometryFromWkt( \"POINT (2 49)\" ) )\n"
"feat.SetGeomFieldDirectly( \"PointField2\",\n"
"    ogr.CreateGeometryFromWkt( \"POINT (500000 4500000)\" ) )\n"
"\n"
"if lyr.CreateFeature( feat ) != 0:\n"
"    print( \"Failed to create feature.\\n\" );\n"
"    sys.exit( 1 );"
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:1671
msgid "Writing to OGR using the Arrow C Data interface"
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:1675
msgid ""
"Instead of writing features one at a time, it is also possible to write them "
"by batches, with a column-oriented memory layout, using the :cpp:func:"
"`OGRLayer::WriteArrowBatch` method. Note that this method is more difficult "
"to use than the traditional :cpp:func:`OGRLayer::CreateFeature` approach, "
"and is only advised when compatibility with the `Apache Arrow C Data "
"interface <https://arrow.apache.org/docs/format/CDataInterface.html>`_ is "
"needed, or when column-oriented writing of layers is required."
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:1683
msgid ""
"Pending using an helper library, generation of the Arrow C Data interface "
"requires reading of the following documents:"
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:1689
msgid ""
"Consult :ref:`vector_api_tut_arrow_stream` for introduction to the "
"ArrowSchema and ArrowArray basic types involved for batch writing."
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:1692
msgid "The WriteArrowBatch() method has the following signature:"
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:1694
msgid ""
"/** Writes a batch of rows from an ArrowArray.\n"
" *\n"
" * @param schema Schema of array\n"
" * @param array Array of type struct. It may be released (array-"
">release==NULL)\n"
" *              after calling this method.\n"
" * @param papszOptions Options. Null terminated list, or nullptr.\n"
" * @return true in case of success\n"
" */\n"
"virtual bool OGRLayer::WriteArrowBatch(const struct ArrowSchema *schema,\n"
"                                       struct ArrowArray *array,\n"
"                                       CSLConstList papszOptions = nullptr);"
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:1708
msgid "It is also available in the C API as :cpp:func:`OGR_L_WriteArrowBatch`."
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:1710
msgid ""
"This is semantically close to calling :cpp:func:`OGRLayer::CreateFeature()` "
"with multiple features at once."
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:1713
msgid ""
"The ArrowArray must be of type struct (format=+s), and its children "
"generally map to a OGR attribute or geometry field (unless they are struct "
"themselves)."
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:1716
msgid ""
"Method :cpp:func:`OGRLayer::IsArrowSchemaSupported` can be called to "
"determine if the schema will be supported by WriteArrowBatch()."
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:1719
msgid ""
"OGR fields for the corresponding children arrays must exist and be of a "
"compatible type. For attribute fields, they should be created with :cpp:func:"
"`OGRLayer::CreateFieldFromArrowSchema`."
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:1723
msgid ""
"Arrays for geometry columns should be of binary or large binary type and "
"contain WKB geometry."
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:1726
msgid ""
"Note that the passed array may be set to a released state (array-"
">release==NULL) after this call (not by the base implementation, but in "
"specialized ones such as Parquet or Arrow for example)"
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:1730
msgid "Supported options of the base implementation are:"
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:1732
msgid ""
"FID=name. Name of the FID column in the array. If not provided, "
"GetFIDColumn() is used to determine it. The special name OGRLayer::"
"DEFAULT_ARROW_FID_NAME is also recognized if neither FID nor GetFIDColumn() "
"are set. The corresponding ArrowArray must be of type int32 (i) or int64 "
"(l). On input, values of the FID column are used to create the feature. On "
"output, the values of the FID column may be set with the FID of the created "
"feature (if the array is not released)."
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:1741
msgid ""
"GEOMETRY_NAME=name. Name of the geometry column. If not provided, "
"GetGeometryColumn() is used. The special name OGRLayer::"
"DEFAULT_ARROW_GEOMETRY_NAME is also recognized if neither GEOMETRY_NAME nor "
"GetGeometryColumn() are set. Geometry columns are also identified if they "
"have ARROW:extension:name=ogc.wkb as a field metadata. The corresponding "
"ArrowArray must be of type binary (w) or large binary (W)."
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:1750
msgid ""
"Drivers that have a specialized implementation (such as :ref:`vector."
"parquet` and :ref:`vector.arrow`) advertise the OLCFastWriteArrowBatch layer "
"capability."
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:1753
msgid ""
"The following example in Python demonstrates how to copy a layer from one "
"format to another one (assuming it has at most a single geometry column):"
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:1756
msgid ""
"def copy_layer(src_lyr, out_filename, out_format, lcos = {}):\n"
"    stream = src_lyr.GetArrowStream()\n"
"    schema = stream.GetSchema()\n"
"\n"
"    # If the source layer has a FID column and the output driver supports\n"
"    # a FID layer creation option, set it to the source FID column name.\n"
"    if src_lyr.GetFIDColumn():\n"
"        creationOptions = gdal.GetDriverByName(out_format).GetMetadataItem(\n"
"            \"DS_LAYER_CREATIONOPTIONLIST\"\n"
"        )\n"
"        if creationOptions and '\"FID\"' in creationOptions:\n"
"            lcos[\"FID\"] = src_lyr.GetFIDColumn()\n"
"\n"
"    with ogr.GetDriverByName(out_format).CreateDataSource(out_filename) as "
"out_ds:\n"
"        if src_lyr.GetLayerDefn().GetGeomFieldCount() > 1:\n"
"            out_lyr = out_ds.CreateLayer(\n"
"                src_lyr.GetName(), geom_type=ogr.wkbNone, options=lcos\n"
"            )\n"
"            for i in range(src_lyr.GetLayerDefn().GetGeomFieldCount()):\n"
"                out_lyr.CreateGeomField(src_lyr.GetLayerDefn()."
"GetGeomFieldDefn(i))\n"
"        else:\n"
"            out_lyr = out_ds.CreateLayer(\n"
"                src_lyr.GetName(),\n"
"                geom_type=src_lyr.GetGeomType(),\n"
"                srs=src_lyr.GetSpatialRef(),\n"
"                options=lcos,\n"
"            )\n"
"\n"
"        success, error_msg = out_lyr.IsArrowSchemaSupported(schema)\n"
"        assert success, error_msg\n"
"\n"
"        src_geom_field_names = [\n"
"            src_lyr.GetLayerDefn().GetGeomFieldDefn(i).GetName()\n"
"            for i in range(src_lyr.GetLayerDefn().GetGeomFieldCount())\n"
"        ]\n"
"        for i in range(schema.GetChildrenCount()):\n"
"            # GetArrowStream() may return \"OGC_FID\" for a unnamed source "
"FID\n"
"            # column and \"wkb_geometry\" for a unnamed source geometry "
"column.\n"
"            # Also test GetFIDColumn() and src_geom_field_names if they are\n"
"            # named.\n"
"            if (\n"
"                schema.GetChild(i).GetName()\n"
"                not in (\"OGC_FID\", \"wkb_geometry\", src_lyr."
"GetFIDColumn())\n"
"                and schema.GetChild(i).GetName() not in "
"src_geom_field_names\n"
"            ):\n"
"                out_lyr.CreateFieldFromArrowSchema(schema.GetChild(i))\n"
"\n"
"        write_options = []\n"
"        if src_lyr.GetFIDColumn():\n"
"            write_options.append(\"FID=\" + src_lyr.GetFIDColumn())\n"
"        if (\n"
"            src_lyr.GetLayerDefn().GetGeomFieldCount() == 1\n"
"            and src_lyr.GetGeometryColumn()\n"
"        ):\n"
"            write_options.append(\"GEOMETRY_NAME=\" + src_lyr."
"GetGeometryColumn())\n"
"\n"
"        while True:\n"
"            array = stream.GetNextRecordBatch()\n"
"            if array is None:\n"
"                break\n"
"            out_lyr.WriteArrowBatch(schema, array, write_options)"
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:1821
msgid ""
"For the Python bindings, in addition to the above ogr.Layer."
"IsArrowSchemaSupported(), ogr.Layer.CreateFieldFromArrowSchema() and ogr."
"Layer.WriteArrowBatch() methods, 3 similar methods exist using the `PyArrow "
"<https://arrow.apache.org/docs/python/index.html>`__ data types:"
msgstr ""

#: ../../../source/tutorials/vector_api_tut.rst:1826
msgid ""
"class Layer:\n"
"\n"
"    def IsPyArrowSchemaSupported(self, pa_schema, options=[]):\n"
"        \"\"\"Returns whether the passed pyarrow Schema is supported by the "
"layer, as a tuple (success: bool, errorMsg: str).\n"
"\n"
"    def CreateFieldFromPyArrowSchema(self, pa_schema, options=[]):\n"
"        \"\"\"Create a field from the passed pyarrow Schema.\"\"\"\n"
"\n"
"    def WritePyArrow(self, pa_batch, options=[]):\n"
"        \"\"\"Write the content of the passed PyArrow batch (either a "
"pyarrow.Table, a pyarrow.RecordBatch or a pyarrow.StructArray) into the "
"layer.\"\"\""
msgstr ""
